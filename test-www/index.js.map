{
  "version": 3,
  "sources": ["../test/index.ts", "../test/helpers/scenes/TestPixelText.ts", "../src/index.ts", "../src/utils/math.ts", "../src/utils/arrayUtils.ts", "../src/utils/propertyListeners.ts", "../src/utils/threeUtils.ts", "../src/utils/colorLibrary.ts", "../src/PixelFontFace.ts", "../src/loaders/assetLoader.ts", "../src/PixelTextSettings.ts", "../test/loaders/assetLoader.ts", "../test/utils/fpsControls.ts", "../test/renderer.ts", "../test/utils/location.ts", "../test/utils/colors.ts", "../test/utils/math.ts", "../test/constants.ts", "../test/device.ts", "../test/uniforms.ts", "../test/utils/arrayUtils.ts", "../test/utils/localStorage.ts", "../test/utils/NiceParameter.ts", "../test/utils/cameraShaker.ts", "../test/utils/UpdateManager.ts", "../test/helpers/scenes/BaseTestScene.ts", "../test/helpers/scenes/TestManyLabelsScene.ts", "../test/tests.ts", "../test/utils/onNextFrame.ts"],
  "sourcesContent": ["import { Clock, Color, Vector3 } from 'three'\n\nimport { BaseTestScene } from './helpers/scenes/BaseTestScene'\nimport TestPixelTextScene from './helpers/scenes/TestPixelText'\nimport renderer from './renderer'\nimport { testClasses } from './tests'\nimport { timeUniform } from './uniforms'\nimport { cameraShaker } from './utils/cameraShaker'\nimport { getUrlParam } from './utils/location'\nimport { nextFrameUpdate } from './utils/onNextFrame'\nimport UpdateManager from './utils/UpdateManager'\n\ndocument.addEventListener('gesturestart', (e) => e.preventDefault()) // disable zooming on mobile\n\nconst clock = new Clock()\nrenderer.setClearColor(new Color(0x344556), 1.0)\ncameraShaker.camera.position.set(0, 0.5, 0.5)\ncameraShaker.camera.lookAt(new Vector3())\n\nlet TestClass: new () => BaseTestScene = TestPixelTextScene\nconst testParam = getUrlParam('test') || 'pixelText'\nif (testClasses.hasOwnProperty(testParam)) {\n  TestClass = testClasses[testParam]\n}\n\nconst test: BaseTestScene = new TestClass()\n\nconst nthFrame: number = parseInt(getUrlParam('nthFrame') || '1')\nlet frameCounter = 0\nlet renderDt = 0\nconst loop = () => {\n  frameCounter++\n  const dt = clock.getDelta()\n  renderDt += dt\n\n  nextFrameUpdate()\n  UpdateManager.update(dt)\n  timeUniform.value += dt\n\n  test.update(dt)\n  if (frameCounter % nthFrame !== 0) {\n    requestAnimationFrame(loop)\n    return\n  }\n  test.render(renderer, renderDt)\n  renderDt = 0\n\n  requestAnimationFrame(loop)\n}\n\n// Start loop\nrequestAnimationFrame(loop)\n", "import { Color, PerspectiveCamera, WebGLRenderer } from 'three'\nimport PixelTextMesh from '@lib/index'\nimport { loadText } from '~/loaders/assetLoader'\nimport PixelFontFace from '@lib/PixelFontFace'\nimport { FPSControls } from '~/utils/fpsControls'\nimport { getUrlFlag } from '~/utils/location'\n\nimport { BaseTestScene } from './BaseTestScene'\n\nfunction url(name: string, ext: string) {\n  return `books/${name}.${ext}`\n}\n\nexport default class TestPixelTextScene extends BaseTestScene {\n  constructor() {\n    super()\n    this.camera.position.set(0, 0, 0.5)\n    this.camera.lookAt(0, 0, 0)\n    // this.camera.updateProjectionMatrix()\n    const fps = new FPSControls(this.camera as PerspectiveCamera)\n    if (getUrlFlag('fpsCam')) {\n      fps.toggle(true)\n    }\n\n    // const s = 1\n\n    // const hello = new PixelTextMesh(' ABC \\n 010 \\n ntz \\n \"#% \\n { } \\n0ANan')\n    // // const hello = new PixelTextMesh('This is the beginning!\\nHello World!\\nHello World!\\nHello World!\\nHello World!')\n    // hello.scale.multiplyScalar(s)\n    // this.scene.add(hello)\n\n    const init = async () => {\n      let bookText = 'Hello world.'\n      bookText = await loadText(url('augustine-confessions-276', 'txt'))\n      // bookText = '1.0\\n1.0.3\\n1.0.31\\n1.0.3 1\\n1 .0.3 1\\n-.-.E.E-E'\n      // bookText = '\u00A9 Tomasz Dysinski. Here & now.'\n      const book = new PixelTextMesh(\n        bookText,\n        {\n          align: 0,\n          vAlign: 0,\n          // fontFace: new PixelFontFace('pixelFonts/cdogs_font_7x8', 7, 8),\n          fontFace: new PixelFontFace('pixelFonts/good_neighbors', 11, 16),\n          color: new Color(1, 1, 1),\n          letterSpacing: -1,\n          strokeColor: new Color(0, 0, 0),\n          scaleDownToPhysicalSize: true,\n          screenSpace: false,\n          constantSizeOnScreen: false,\n          prescale: 1\n        },\n        undefined,\n        (w, h) => {\n          book.scale.x = 0.01 * w\n          book.scale.y = 0.01 * h\n        }\n      )\n      book.position.set(-0.125, 0, 0)\n      this.scene.add(book)\n    }\n    init()\n  }\n  update(dt: number) {\n    super.update(dt)\n  }\n  render(renderer: WebGLRenderer, dt: number) {\n    super.render(renderer, dt)\n  }\n}\n", "import {\n  BufferGeometry,\n  Camera,\n  Color,\n  DataTexture,\n  Group,\n  IUniform,\n  Material,\n  Matrix4,\n  Mesh,\n  NearestFilter,\n  PlaneBufferGeometry,\n  RGBAFormat,\n  RepeatWrapping,\n  Scene,\n  ShaderMaterial,\n  Texture,\n  Uniform,\n  UnsignedByteType,\n  UVMapping,\n  Vector2,\n  Vector4,\n  WebGLRenderer,\n  RawShaderMaterial\n} from 'three'\nimport {\n  listenToProperty,\n  stopListeningToProperty\n} from './utils/propertyListeners'\nimport { getTempTexture } from './utils/threeUtils'\n\nimport fragmentShader from './frag.glsl'\nimport PixelFontFace from './PixelFontFace'\nimport { pixelTextSettings, PixelTextSettings } from './PixelTextSettings'\nimport vertexShader from './vert.glsl'\n\nconst __mat = new Matrix4()\n\nconst trackedFontFaceTextures: Texture[] = []\nfunction getFontFaceSubOrder(texture?: Texture) {\n  if (!texture) {\n    return -1\n  }\n  const index = trackedFontFaceTextures.indexOf(texture)\n  if (index === -1) {\n    trackedFontFaceTextures.push(texture)\n    return trackedFontFaceTextures.length - 1\n  } else {\n    return index\n  }\n}\n\nconst MAX_LINES = 2048\n\nexport default class PixelTextMesh extends Mesh {\n  width = 0\n  height = 0\n\n  dirty = false\n  livePropObject?: object\n  livePropName?: string\n\n  private _fontFace: PixelFontFace | undefined\n  private _newTexture?: Texture\n  private _newFontString?: string\n\n  constructor(\n    private _text = '',\n    public settings: PixelTextSettings = pixelTextSettings.generic,\n    public onMeasurementsUpdated?: (mesh: PixelTextMesh) => void,\n    public onCharSizeUpdated?: (width: number, height: number) => void,\n    public optimizeRenderOrder = true\n  ) {\n    super(getTextGeometry(_text, settings), initMaterial(settings))\n\n    listenToProperty(settings, 'fontFace', this.onFontFaceChange, true)\n  }\n\n  get text() {\n    return this._text\n  }\n\n  set text(text: string) {\n    if (this._text !== text) {\n      this._text = text\n      this.dirty = true\n    }\n  }\n\n  onFontFaceChange = (\n    newFontFace: PixelFontFace,\n    oldFontFace: PixelFontFace\n  ) => {\n    if (oldFontFace) {\n      stopListeningToProperty(oldFontFace, 'texture', this.onFontTextureUpdate)\n      stopListeningToProperty(oldFontFace, 'font', this.onFontUpdate)\n    }\n    listenToProperty(newFontFace, 'texture', this.onFontTextureUpdate)\n    listenToProperty(newFontFace, 'font', this.onFontUpdate)\n\n    newFontFace.init()\n    this._fontFace = newFontFace\n  }\n\n  onFontTextureUpdate = (texture: Texture) => {\n    this._newTexture = texture\n    this.dirty = true\n  }\n\n  onFontUpdate = (fontString: string) => {\n    this._newFontString = fontString\n    this.dirty = true\n  }\n\n  onBeforeRender = (\n    renderer: WebGLRenderer,\n    scene: Scene,\n    camera: Camera,\n    geometry: BufferGeometry,\n    material: Material,\n    group: Group\n  ) => {\n    if (this.settings.screenSpace) {\n      const clipPos = (this.material as ShaderMaterial)!.uniforms\n        .clipSpacePosition.value as Vector4\n      __mat\n        .multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld)\n        .premultiply(camera.projectionMatrix)\n      //.multiply(camera.projectionMatrix)\n      clipPos.set(0, 0, 0, 1).applyMatrix4(__mat)\n    }\n    if (this.dirty) {\n      this.dirty = false\n      this.regenerateGeometry()\n      const m = this.material as ShaderMaterial\n      if (this._newTexture) {\n        if (this.optimizeRenderOrder) {\n          this.renderOrder =\n            this.renderOrder || 100 + getFontFaceSubOrder(this._newTexture)\n        }\n        m.uniforms.fontTexture.value = this._newTexture\n        this._newTexture = undefined\n      }\n      if (this._newFontString && this._text) {\n        const lines = this.text.split('\\n').slice(0, MAX_LINES)\n        const charsHeight = lines.length\n\n        const fontSettings = this.settings.fontFace\n        const maxWidthOfChar = fontSettings.maxCharPixelWidth\n        const fontString = fontSettings.font!\n        const charPixelWidths = fontSettings.pixelWidths!\n\n        const overlapPixels = -this.settings.letterSpacing\n\n        const image = (m.uniforms.fontTexture.value as Texture).image\n        m.uniforms.fontSizeInChars.value.set(\n          image.width / fontSettings.maxCharPixelWidth,\n          image.height / fontSettings.charPixelHeight\n        )\n\n        const missingCharIndex = fontString.indexOf('\u25A1')\n        if (missingCharIndex === -1) {\n          throw new Error(\n            'Please include this character \u25A1 in your font, to stand in for other missing characters'\n          )\n        }\n\n        let missingChars = ''\n\n        const linePixelWidths = lines.map((lineString) => {\n          let pixelLength = 0\n          for (let i = 0; i < lineString.length; i++) {\n            const char = lineString[i]\n            if (char == undefined) {\n              continue\n            }\n            const charIndex = fontString.indexOf(char)\n            if (charIndex === -1) {\n              pixelLength +=\n                maxWidthOfChar -\n                charPixelWidths[missingCharIndex] -\n                overlapPixels\n              if (!missingChars.includes(char)) {\n                missingChars += char\n              }\n            } else {\n              pixelLength +=\n                maxWidthOfChar - charPixelWidths[charIndex] - overlapPixels\n            }\n          }\n          return pixelLength + overlapPixels\n        })\n\n        console.warn('Characters in text not found in font: ' + missingChars)\n\n        const maxPixelWidth = linePixelWidths.reduce(\n          (p, c) => Math.max(p, c),\n          0\n        )\n\n        const total = maxPixelWidth * charsHeight\n        const data = new Uint8Array(total * 4)\n\n        for (let iy = 0; iy < charsHeight; iy++) {\n          const lineOffset = iy * maxPixelWidth\n          let xCursor = 0\n          const line = lines[iy]\n          const charsWidth = line.length\n          for (let ix = 0; ix <= charsWidth; ix++) {\n            const char = line[ix]\n            const prevChar = line[ix - 1]\n            if (!char && !prevChar) {\n              continue\n            }\n            let charIndex = fontString.indexOf(char)\n            if (charIndex === -1 && char !== undefined) {\n              charIndex = missingCharIndex\n            }\n            const charPixelWidth = maxWidthOfChar - charPixelWidths[charIndex]\n            for (let ipx = 0; ipx < charPixelWidth; ipx++) {\n              const index = (lineOffset + xCursor) * 4\n              data[index] = charIndex\n              data[index + 1] = (((xCursor - ipx) / maxWidthOfChar) % 1) * 255\n              xCursor++\n            }\n\n            //back up to overlap chars\n            xCursor -= overlapPixels\n            for (let i = 0; i < overlapPixels; i++) {\n              const index = (lineOffset + xCursor + i) * 4\n              data[index + 2] = data[index]\n              data[index + 3] = data[index + 1]\n            }\n          }\n        }\n        m.uniforms.layoutSizeInChars.value.set(\n          maxPixelWidth / maxWidthOfChar,\n          charsHeight\n        )\n        m.uniforms.layoutSizeInCharColumns.value.set(maxPixelWidth, charsHeight)\n        m.uniforms.layoutTexture.value = new DataTexture(\n          data,\n          maxPixelWidth,\n          charsHeight,\n          RGBAFormat,\n          UnsignedByteType,\n          UVMapping,\n          RepeatWrapping,\n          RepeatWrapping,\n          NearestFilter,\n          NearestFilter\n        )\n        this._newFontString = undefined\n        if (this.onCharSizeUpdated) {\n          this.onCharSizeUpdated(maxPixelWidth / maxWidthOfChar, charsHeight)\n        }\n      }\n    }\n  }\n\n  updateText = (value: any = '') => {\n    this.text = `${value}`\n  }\n\n  onRemove() {\n    stopListeningToProperty(this.settings, 'fontFace', this.onFontFaceChange)\n    if (this._fontFace) {\n      stopListeningToProperty(\n        this._fontFace,\n        'texture',\n        this.onFontTextureUpdate\n      )\n      stopListeningToProperty(this._fontFace, 'font', this.onFontUpdate)\n    }\n  }\n\n  private regenerateGeometry() {\n    this.geometry = getTextGeometry(this._text, this.settings)\n    this.updateMeasurements()\n  }\n\n  private updateMeasurements() {\n    const bb = this.geometry.boundingBox!\n    this.width = bb.max.x - bb.min.x\n    this.height = Math.abs(bb.max.y - bb.min.y)\n    this.userData.resolution = new Vector2(this.width, this.height)\n    if (this.onMeasurementsUpdated) {\n      this.onMeasurementsUpdated(this)\n    }\n  }\n}\n\ninterface TextShaderUniforms {\n  fontTexture: IUniform<Texture>\n  layoutTexture: IUniform<Texture>\n  color: IUniform<Color>\n  strokeColor: IUniform<Color>\n  clipSpacePosition?: IUniform<Vector4>\n  pixelSizeInClipSpace?: IUniform<Vector2>\n  prescale?: IUniform<number>\n  alignment?: IUniform<Vector2>\n}\n\nconst initMaterial = (settings: PixelTextSettings) => {\n  const uniforms = {\n    layoutTexture: new Uniform(getTempTexture()),\n    fontTexture: new Uniform(settings.fontFace.texture),\n    color: new Uniform(new Color(settings.color)),\n    strokeColor: new Uniform(new Color(settings.strokeColor)),\n    fontSizeInChars: new Uniform(new Vector2(1, 1)),\n    layoutSizeInChars: new Uniform(new Vector2(1, 1)),\n    layoutSizeInCharColumns: new Uniform(new Vector2(1, 1)),\n    alignment: new Uniform(\n      new Vector2(settings.align, -settings.vAlign)\n    )\n  }\n  const safeUniforms: TextShaderUniforms = uniforms\n\n  if (settings.screenSpace) {\n    safeUniforms.prescale = new Uniform(settings.prescale)\n    safeUniforms.clipSpacePosition = new Uniform(new Vector4())\n    if (settings.pixelSizeInClipSpaceUniform) {\n      safeUniforms.pixelSizeInClipSpace = settings.pixelSizeInClipSpaceUniform\n    } else {\n      throw new Error(\n        'You must provide a pixelSizeInClipSpaceUniform for screenSpace mode'\n      )\n    }\n  }\n\n  const material = new RawShaderMaterial({\n    defines: {\n      USE_SCREENSPACE: settings.screenSpace,\n      CONSTANT_SIZE_ON_SCREEN: settings.constantSizeOnScreen\n    },\n    uniforms,\n    vertexShader,\n    fragmentShader,\n    depthWrite: true\n  })\n\n  return material\n}\n\nconst tempBlankGeo = new PlaneBufferGeometry(0.001, 0.001)\ntempBlankGeo.computeBoundingBox()\nconst textGeo = new PlaneBufferGeometry(1, 1)\nconst attr = textGeo.attributes.position\nconst arr = attr.array as number[]\nfor (let i = 0; i < attr.count; i++) {\n  const i3 = i * 3\n  arr[i3] += 0.5\n  arr[i3 + 1] -= 0.5\n}\ntextGeo.computeBoundingBox()\n\nconst getTextGeometry = (\n  text: string,\n  settings: PixelTextSettings\n): BufferGeometry => {\n  if (settings.fontFace.font && text) {\n    return textGeo\n  } else {\n    return tempBlankGeo\n  }\n}\n", "import { Camera, Plane, Ray, Vector3 } from 'three'\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.min(max, Math.max(min, val))\n}\n\nexport function mod(val: number, freq: number) {\n  return ((val % freq) + freq) % freq\n}\n\nexport function wrap(val: number, min: number, max: number) {\n  const range = max - min\n  return ((((val - min) % range) + range) % range) + min\n}\n\nexport function absFloor(val: number) {\n  return Math.floor(Math.abs(val)) * (val < 0 ? -1 : 1)\n}\n\nconst tiny = 0.00001\nexport function closeEnough(val: number, val2: number) {\n  return Math.abs(val - val2) < tiny\n}\n\nexport const TWO_PI = 2 * Math.PI\n\nexport const RADIANS_TO_DEGREES = 180 / Math.PI\n\nexport const DEGREES_TO_RADIANS = Math.PI / 180\n\nexport function radiansToDegrees(radians: number) {\n  return radians * RADIANS_TO_DEGREES\n}\n\nexport function degreesToRadians(degrees: number) {\n  return degrees * DEGREES_TO_RADIANS\n}\n\nconst ray: Ray = new Ray()\nconst flatPlane: Plane = new Plane(new Vector3(0, -1, 0), 1)\nconst anyPlane: Plane = new Plane(new Vector3(0, -1, 0), 1)\nconst intersection: Vector3 = new Vector3()\n\n// const __cameraPosition = new Vector3()\n\nexport function get2DPositionOnPlane(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  plane: Plane\n) {\n  // __cameraPosition.set(0, 0, 0)\n  // camera.localToWorld(__cameraPosition)\n  ray.origin.copy(cameraWorldPos)\n  ray.direction.set(x, y, 0.5).unproject(camera).sub(cameraWorldPos).normalize()\n\n  ray.intersectPlane(plane, intersection)\n  return intersection\n}\nexport function get2DPositionAtDepth(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  atDepth = 0\n) {\n  flatPlane.constant = atDepth\n  return get2DPositionOnPlane(camera, cameraWorldPos, x, y, flatPlane)\n}\nexport function get2DPositionOnPlaneHelper(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  coPlanarPoint: Vector3,\n  normal: Vector3\n) {\n  anyPlane.setFromNormalAndCoplanarPoint(normal, coPlanarPoint)\n  return get2DPositionOnPlane(camera, cameraWorldPos, x, y, anyPlane)\n}\n\nexport function lerp(a: number, b: number, dt: number) {\n  const out = a + dt * (b - a)\n  return Math.abs(b - out) > 0.00001 ? out : b\n}\n\nexport function unlerp(min: number, max: number, value: number) {\n  return (value - min) / (max - min)\n}\n\nexport function unlerpClamped(min: number, max: number, value: number) {\n  return clamp(unlerp(min, max, value), 0, 1)\n}\n\nexport function degreesDifference(A: number, B: number) {\n  return ((((A - B) % 360) + 540) % 360) - 180\n}\n\nconst tau = Math.PI * 2\nconst tauAndHalf = Math.PI * 3\nexport function radiansDifference(a: number, b: number) {\n  return ((((a - b) % tau) + tauAndHalf) % tau) - Math.PI\n}\n\nexport function rand(min = 0, max = 1) {\n  return Math.random() * (max - min) + min\n}\n\nexport function rand2(scale = 1, offset = 0) {\n  return (Math.random() * 2 - 1) * scale + offset\n}\n\nexport function nextHighestPowerOfTwo(val: number) {\n  return Math.pow(Math.ceil(Math.sqrt(val)), 2)\n}\n\nexport function inferDirection(val: number, tolerance = 0.00001) {\n  if (val < -tolerance) {\n    return -1\n  } else if (val > tolerance) {\n    return 1\n  } else {\n    return 0\n  }\n}\n\nexport function sqr(v: number) {\n  return v * v\n}\n\nexport function pixelLengthOnScreen(a: Vector3, b: Vector3, camera: Camera) {\n  a.project(camera)\n  b.project(camera)\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n}\n\nconst phi = (Math.sqrt(5) + 1) * 0.5 - 1\nconst ga = phi * Math.PI * 2\nexport function pointOnSphereFibonacci(\n  index: number,\n  total: number\n): [number, number] {\n  //[long, lat];\n  return [ga * index, Math.asin(-1 + (2 * index) / total)]\n}\n\nexport function longLatToXYZ(\n  longLat: [number, number],\n  radius: number\n): [number, number, number] {\n  const long = longLat[0]\n  const lat = longLat[1]\n  return [\n    Math.cos(lat) * Math.cos(long) * radius,\n    Math.sin(lat) * radius,\n    Math.cos(lat) * Math.sin(long) * radius\n  ]\n}\n\nexport function powerOfTwo(x: number) {\n  return Math.log2(x) % 1 === 0\n}\n\nexport function assertPowerOfTwo(x: number) {\n  if (!powerOfTwo(x)) {\n    throw new Error(`${x} is not a power of two`)\n  }\n}\n", "import { absFloor, clamp } from './math'\nexport const scaleValuesInArray = (arr: number[], scale: number) => {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] *= scale\n  }\n}\n\nexport const addToArrayUnique = <T>(arr: T[], value: T) => {\n  const index = arr.indexOf(value)\n  if (index === -1) {\n    arr.push(value)\n  }\n}\n\nexport const removeFromArray = <T>(arr: T[], value: T, strict = false) => {\n  const index = arr.indexOf(value)\n  if (index !== -1) {\n    arr.splice(index, 1)\n  } else if (strict) {\n    throw new Error('could not find value in array')\n  }\n  return value\n}\n\nexport const moveBetweenArrays = <T>(src: T[], dst: T[], value: T) => {\n  dst.push(removeFromArray(src, value))\n  return value\n}\n\nexport const replaceManyInArray = <T>(\n  arr: Array<T | undefined>,\n  value: T,\n  replacement?: T\n) => {\n  if (value === replacement) {\n    throw new Error('Nope. This would cause an infinite loop')\n  }\n  let index = arr.indexOf(value)\n  while (index !== -1) {\n    arr[index] = replacement\n    index = arr.indexOf(value)\n  }\n}\n\nexport function getArrayDiffs<T>(oldArr: T[], newArr: T[]) {\n  const added = newArr.filter((item) => !oldArr.includes(item))\n\n  const removed = oldArr.filter((item) => !newArr.includes(item))\n\n  const equal = newArr.filter((item) => oldArr.includes(item))\n\n  return {\n    added,\n    removed,\n    equal\n  }\n}\n\nexport const pushToArrayMap = <T, T2>(\n  map: Map<T, T2[]>,\n  key: T,\n  value: T2,\n  oneCopyMax = false\n) => {\n  if (!map.has(key)) {\n    map.set(key, [])\n  }\n  const arr = map.get(key) as T2[]\n  if (arr) {\n    if (oneCopyMax) {\n      if (arr.indexOf(value) === -1) {\n        arr.push(value)\n      }\n    } else {\n      arr.push(value)\n    }\n  }\n}\n\nexport const cleanRemoveFromArrayMap = <T, T2>(\n  map: Map<T, T2[]>,\n  key: T,\n  value: T2\n) => {\n  if (!map.has(key)) {\n    return\n  }\n  const arr = map.get(key) as T2[]\n  if (arr) {\n    removeFromArray(arr, value)\n    if (arr.length === 0) {\n      map.delete(key)\n    }\n  }\n}\n\nfunction signMatches(val: number, val2: number) {\n  return val >= 0 === val2 >= 0\n}\n//binary search only works assuming numbers have been sorted from lowest to highest\nexport function findClosestNumberIndex(arr: number[], value: number): number {\n  const middleIndex = ~~(arr.length * 0.5)\n  let step = value > arr[middleIndex] ? 1 : -1\n  let index = middleIndex\n  let oldSample = arr[index]\n  let everTurned = false\n  let limit = 100\n  while (step !== 0 && limit > 0) {\n    index = clamp(index + step, 0, arr.length - 1)\n    const newSample = arr[index]\n    if (!signMatches(value - newSample, value - oldSample)) {\n      step *= -1\n      everTurned = true\n    }\n    step = absFloor(step * (everTurned ? 0.5 : 2))\n    oldSample = newSample\n    limit--\n  }\n  return index\n}\n\nexport function getArrWrap<T>(arr: T[], i: number) {\n  const t = arr.length\n  return arr[((i % t) + t) % t]\n}\n\nexport function getArrNext<T>(arr: T[], item: T) {\n  return getArrWrap(arr, arr.indexOf(item) + 1)\n}\n\nexport function getArrPrev<T>(arr: T[], item: T) {\n  return getArrWrap(arr, arr.indexOf(item) - 1)\n}\n\nexport function getArrAround<T>(arr: T[], item: T) {\n  const i = arr.indexOf(item)\n  return [getArrWrap(arr, i - 1), item, getArrWrap(arr, i + 1)]\n}\n", "import { removeFromArray } from './arrayUtils'\n\ntype ChangeCallback = (newVal: any, oldVal: any) => void\n\nclass LiveProperty {\n  get listenerCount() {\n    return this.listeners.length\n  }\n  private obj: any\n  private propName: string\n  private value: any\n  private listeners: ChangeCallback[]\n  constructor(obj: any, propName: string) {\n    this.propName = propName\n    this.listeners = []\n    this.setValue = this.setValue.bind(this)\n    this.attach(obj)\n  }\n\n  attach(obj: any) {\n    if (this.obj) {\n      this.release()\n    }\n    this.obj = obj\n    const value = this.obj[this.propName]\n    Object.defineProperty(obj, this.propName, {\n      configurable: true,\n      set: this.setValue,\n      get: () => this.value\n    })\n    this.setValue(value)\n  }\n  release() {\n    Object.defineProperty(this.obj, this.propName, {\n      value: this.value,\n      writable: true\n    })\n  }\n  hasListener(listener: ChangeCallback) {\n    return this.listeners.indexOf(listener) !== -1\n  }\n  addListener(listener: ChangeCallback, firstOneForFree = true) {\n    if (firstOneForFree) {\n      listener(this.value, undefined)\n    }\n    this.listeners.push(listener)\n  }\n  removeListener(listener: ChangeCallback) {\n    removeFromArray(this.listeners, listener)\n  }\n  private setValue(value: any) {\n    if (this.value === value) {\n      return\n    }\n    const oldValue = this.value\n    this.value = value\n    for (const listener of this.listeners) {\n      listener(value, oldValue)\n    }\n  }\n}\n\nconst propGroupLibrary = new Map<any, Map<string, LiveProperty>>()\n\nfunction getObjectPropGroup(obj: any) {\n  if (!propGroupLibrary.has(obj)) {\n    propGroupLibrary.set(obj, new Map<string, LiveProperty>())\n  }\n  return propGroupLibrary.get(obj)!\n}\n\nfunction getLiveProperty(obj: any, propName: string) {\n  const objectPropGroup = getObjectPropGroup(obj)\n  if (!objectPropGroup.has(propName)) {\n    objectPropGroup.set(propName, new LiveProperty(obj, propName))\n  }\n  return objectPropGroup.get(propName)!\n}\n\nexport function listenToProperty(\n  obj: any,\n  propName: string,\n  onChange: ChangeCallback,\n  firstOneForFree = true\n) {\n  getLiveProperty(obj, propName).addListener(onChange, firstOneForFree)\n}\n\nexport function stopListeningToProperty(\n  obj: any,\n  propName: string,\n  onChange: ChangeCallback\n) {\n  const propGroup = propGroupLibrary.get(obj)\n  if (propGroup) {\n    const liveProp = propGroup.get(propName)\n    if (liveProp) {\n      liveProp.removeListener(onChange)\n      if (liveProp.listenerCount === 0) {\n        liveProp.release()\n        propGroup.delete(propName)\n      }\n    }\n    if (propGroup.size === 0) {\n      propGroupLibrary.delete(obj)\n    }\n  }\n}\n\nexport function migrateLiveProperty(\n  oldObj: any,\n  newObj: any,\n  propName: string\n) {\n  const oldPropGroup = propGroupLibrary.get(oldObj)\n  if (oldPropGroup) {\n    const liveProp = oldPropGroup.get(propName)\n    if (liveProp) {\n      liveProp.attach(newObj)\n      oldPropGroup.delete(propName)\n      const newPropGroup = getObjectPropGroup(newObj)\n      newPropGroup.set(propName, liveProp)\n      if (oldPropGroup.size === 0) {\n        propGroupLibrary.delete(oldObj)\n      }\n    }\n  }\n}\n", "import { DataTexture, RGBAFormat, UnsignedByteType } from 'three'\n\nlet __tempTexture: DataTexture | undefined\nexport function getTempTexture() {\n  if (!__tempTexture) {\n    const s = 4\n    const total = s * s * 4\n    const data = new Uint8Array(total)\n    for (let i = 0; i < total; i++) {\n      data[i] = 0\n    }\n    __tempTexture = new DataTexture(data, s, s, RGBAFormat, UnsignedByteType)\n  }\n  return __tempTexture!\n}\n", "import { Color } from 'three'\n\nexport const COLOR_BLACK: Readonly<Color> = new Color(0x000000)\nexport const COLOR_WHITE: Readonly<Color> = new Color(0xffffff)\nexport const COLOR_HIGHLIGHT_GREEN: Readonly<Color> = new Color(0x66ff66)\nexport const COLOR_HIGHLIGHT_RED: Readonly<Color> = new Color(0x22afff)\nexport const COLOR_BUFFED_TEXT: Readonly<Color> = new Color(0x66ff66)\nexport const COLOR_NERFED_TEXT: Readonly<Color> = new Color(0xff0000)\nexport const COLOR_DYNAMIC_COST_TEXT: Readonly<Color> = new Color(0xf4e842)\n", "import { NearestFilter, Texture } from 'three'\nimport { loadText, loadTexture } from './loaders/assetLoader'\n\nfunction url(path: string, ext: string) {\n  return `${path}.${ext}`\n}\nexport default class PixelFontFace {\n  font?: string\n  pixelWidths?: number[]\n  texture?: Texture\n  private _initd = false\n  constructor(\n    public name: string,\n    public maxCharPixelWidth = 7,\n    public charPixelHeight = 8\n  ) {}\n  async init() {\n    if (this._initd) {\n      return\n    }\n    this._initd = true\n\n    this.texture = await loadTexture(url(this.name, 'png'))\n    this.texture.minFilter = NearestFilter\n    this.texture.magFilter = NearestFilter\n\n    const pixelWidthsString = (\n      await loadText(url(this.name + '_char-widths', 'txt'))\n    )\n      .split('\\n')\n      .join('')\n    const pixelWidths = []\n    for (let i = 0; i < pixelWidthsString.length; i++) {\n      pixelWidths[i] = parseInt(pixelWidthsString[i])\n    }\n    this.pixelWidths = pixelWidths\n    this.font = (await loadText(url(this.name, 'txt'))).split('\\n').join('')\n  }\n}\n\nexport const pixelFontFaces = {\n  cdogs_font_7x8: new PixelFontFace('pixelFonts/cdogs_font_7x8', 7, 8),\n  good_neighbors: new PixelFontFace('pixelFonts/good_neighbors', 11, 16)\n}\n", "import { FileLoader, LoadingManager, Texture, TextureLoader } from 'three'\n\nconst __loadingManager = new LoadingManager()\n\nlet __fileLoader: FileLoader | undefined\nfunction getFileLoader() {\n  if (!__fileLoader) {\n    __fileLoader = new FileLoader(__loadingManager)\n  }\n  return __fileLoader\n}\n\nlet __textureLoader: TextureLoader | undefined\nfunction getTextureLoader() {\n  if (!__textureLoader) {\n    __textureLoader = new TextureLoader(__loadingManager)\n  }\n  return __textureLoader\n}\n\nexport async function loadJson(url: string): Promise<object> {\n  return new Promise<object>((resolve, reject) =>\n    getFileLoader().load(\n      url,\n      (fileContents: any) => resolve(JSON.parse(fileContents)),\n      undefined,\n      reject\n    )\n  )\n}\n\nexport async function loadText(url: string): Promise<string> {\n  return new Promise<string>((resolve, reject) =>\n    getFileLoader().load(\n      url,\n      (fileContents: any) => resolve(fileContents),\n      undefined,\n      reject\n    )\n  )\n}\n\nconst __currentlyLoadingTextureResolvers = new Map<\n  string,\n  Array<(texture: Texture) => void>\n>()\nexport async function loadTexture(\n  url: string,\n  flipY?: boolean\n): Promise<Texture> {\n  let promise: Promise<Texture>\n  if (__currentlyLoadingTextureResolvers.has(url)) {\n    promise = new Promise<Texture>((resolve, reject) => {\n      __currentlyLoadingTextureResolvers.get(url)!.push(resolve)\n    })\n  } else {\n    promise = new Promise<Texture>((resolve, reject) => {\n      __currentlyLoadingTextureResolvers.set(url, [resolve])\n      const onLoad = (texture: Texture) => {\n        // texture.needsUpdate = true\n        texture.name = url\n        // texture.encoding = sRGBEncoding\n        if (flipY !== undefined) {\n          texture.flipY = flipY\n        }\n        // XXX Using this filter to get rid of NPOT warnings, is not best quality fix later\n        // texture.minFilter = NearestFilter\n        // texture.magFilter = NearestFilter\n        __currentlyLoadingTextureResolvers\n          .get(url)!\n          .forEach((resolve) => resolve(texture))\n        __currentlyLoadingTextureResolvers.delete(url)\n      }\n      getTextureLoader().load(url, onLoad, undefined, reject)\n    })\n  }\n  return promise\n}\n", "import { Color, Uniform } from 'three'\nimport {\n  COLOR_BLACK,\n  COLOR_BUFFED_TEXT,\n  COLOR_WHITE\n} from './utils/colorLibrary'\n\nimport PixelFontFace, { pixelFontFaces } from './PixelFontFace'\n\nexport interface PixelTextSettings {\n  fontFace: PixelFontFace\n  color: Color\n  align: number\n  vAlign: number\n  strokeColor: Color\n  scaleDownToPhysicalSize: boolean\n  screenSpace: boolean\n  pixelSizeInClipSpaceUniform?: Uniform\n  constantSizeOnScreen?: boolean\n  letterSpacing: number,\n  prescale: number\n}\n\nconst generic: PixelTextSettings = {\n  fontFace: pixelFontFaces.cdogs_font_7x8,\n  align: 0,\n  vAlign: 0,\n  color: COLOR_WHITE,\n  letterSpacing: -1,\n  strokeColor: COLOR_BLACK,\n  scaleDownToPhysicalSize: true,\n  screenSpace: false,\n  constantSizeOnScreen: false,\n  prescale: 1\n}\nconst title: PixelTextSettings = {\n  ...generic,\n  color: COLOR_BUFFED_TEXT\n}\n\nexport const pixelTextSettings = {\n  generic,\n  title\n}\n", "import { FileLoader, LoadingManager, Texture, TextureLoader } from 'three'\n\nconst __loadingManager = new LoadingManager()\n\nlet __fileLoader: FileLoader | undefined\nfunction getFileLoader() {\n  if (!__fileLoader) {\n    __fileLoader = new FileLoader(__loadingManager)\n  }\n  return __fileLoader\n}\n\nlet __textureLoader: TextureLoader | undefined\nfunction getTextureLoader() {\n  if (!__textureLoader) {\n    __textureLoader = new TextureLoader(__loadingManager)\n  }\n  return __textureLoader\n}\n\nexport async function loadJson(url: string): Promise<object> {\n  return new Promise<object>((resolve, reject) =>\n    getFileLoader().load(\n      url,\n      (fileContents: any) => resolve(JSON.parse(fileContents)),\n      undefined,\n      reject\n    )\n  )\n}\n\nexport async function loadText(url: string): Promise<string> {\n  return new Promise<string>((resolve, reject) =>\n    getFileLoader().load(\n      url,\n      (fileContents: any) => resolve(fileContents),\n      undefined,\n      reject\n    )\n  )\n}\n\nconst __currentlyLoadingTextureResolvers = new Map<\n  string,\n  Array<(texture: Texture) => void>\n>()\nexport async function loadTexture(\n  url: string,\n  flipY?: boolean\n): Promise<Texture> {\n  let promise: Promise<Texture>\n  if (__currentlyLoadingTextureResolvers.has(url)) {\n    promise = new Promise<Texture>((resolve, reject) => {\n      __currentlyLoadingTextureResolvers.get(url)!.push(resolve)\n    })\n  } else {\n    promise = new Promise<Texture>((resolve, reject) => {\n      __currentlyLoadingTextureResolvers.set(url, [resolve])\n      const onLoad = (texture: Texture) => {\n        // texture.needsUpdate = true\n        texture.name = url\n        // texture.encoding = sRGBEncoding\n        if (flipY !== undefined) {\n          texture.flipY = flipY\n        }\n        // XXX Using this filter to get rid of NPOT warnings, is not best quality fix later\n        // texture.minFilter = NearestFilter\n        // texture.magFilter = NearestFilter\n        __currentlyLoadingTextureResolvers\n          .get(url)!\n          .forEach((resolve) => resolve(texture))\n        __currentlyLoadingTextureResolvers.delete(url)\n      }\n      getTextureLoader().load(url, onLoad, undefined, reject)\n    })\n  }\n  return promise\n}\n", "import { PerspectiveCamera } from 'three'\nimport FPSController from 'threejs-camera-controller-first-person-desktop'\nimport renderer from '~/renderer'\n\nimport { cameraShaker } from './cameraShaker'\nimport { getUrlFloat } from './location'\nimport { clamp, lerp } from './math'\nimport UpdateManager from './UpdateManager'\n\nconst FPS_CAMERA_DAMPING = getUrlFloat('camDamping', 0, 0, 0.999)\nconst FPS_CAMERA_LERP_STRENGTH = 1 - clamp(FPS_CAMERA_DAMPING, 0, 1)\n\nfunction copyCam(dst: PerspectiveCamera, src: PerspectiveCamera) {\n  dst.position.copy(src.position)\n  dst.scale.copy(src.scale)\n  dst.quaternion.copy(src.quaternion)\n  dst.fov = src.fov\n}\n\nexport class FPSControls {\n  private _active = false\n  private _cameraLocal = new PerspectiveCamera()\n  private _fpsController: FPSController | undefined = undefined\n  constructor(private _camera: PerspectiveCamera) {\n    //\n  }\n  toggle(state?: boolean) {\n    if (state === undefined) {\n      state = !this._active\n    }\n    if (!this._fpsController) {\n      copyCam(this._cameraLocal, this._camera)\n      this._camera.parent!.add(this._cameraLocal)\n      this._fpsController = new FPSController(\n        this._cameraLocal,\n        renderer.domElement,\n        {\n          movementSpeed: 0.01\n        }\n      )\n      UpdateManager.register(this)\n      // setInterval(() => {\n      //   cameraShaker.add(0.025)\n      // }, 2000)\n    }\n    const sig = this._fpsController.onPointerLockAttainSignal\n    const origListener = sig._bindings[0]._listener\n    sig._bindings[0]._listener = () => {\n      if (this._active) {\n        origListener()\n      }\n    }\n    if (!state) {\n      this._fpsController.onPointerLockReleaseSignal.dispatch()\n    }\n    // debugger\n    this._active = state\n  }\n  update() {\n    if (this._active && this._fpsController) {\n      this._fpsController.update()\n      this._camera.position.lerp(\n        this._cameraLocal.position,\n        FPS_CAMERA_LERP_STRENGTH\n      )\n      this._camera.quaternion.slerp(\n        this._cameraLocal.quaternion,\n        FPS_CAMERA_LERP_STRENGTH\n      )\n      this._camera.scale.lerp(this._cameraLocal.scale, FPS_CAMERA_LERP_STRENGTH)\n      // this._camera.matrix.copy(this._cameraLocal.matrix)\n      this._camera.fov = lerp(\n        this._camera.fov,\n        this._cameraLocal.fov,\n        FPS_CAMERA_LERP_STRENGTH\n      )\n      cameraShaker.updateProjection()\n    }\n  }\n}\n\nconst fpsControls = new FPSControls(cameraShaker.camera)\n\nexport default fpsControls\n", "import { PCFShadowMap, sRGBEncoding, WebGLRenderer } from 'three'\nimport { RESET_USER_SETTINGS_TO_DEFAULTS } from '~/constants'\n\nimport device from './device'\nimport {\n  devicePixelRatioUniform,\n  pixelSizeInClipSpaceUniform\n} from './uniforms'\nimport { NiceParameter } from './utils/NiceParameter'\n\nconst canvas = document.createElement('canvas')\n// const context = canvas.getContext('webgl') as WebGLRenderingContext\nconst renderer = new WebGLRenderer({\n  canvas,\n  // context,\n  antialias: true,\n  premultipliedAlpha: false\n  // powerPreference: \"high-performance\"\n  // powerPreference: \"low-power\"\n})\ndocument.body.append(canvas)\nconst attributeValues: string[] = [\n  '-moz-crisp-edges',\n  '-webkit-crisp-edges',\n  'pixelated',\n  'crisp-edges'\n]\n\nattributeValues.forEach((v) => {\n  const canvas = renderer.getContext().canvas\n  if (canvas instanceof HTMLCanvasElement) {\n    canvas.style.setProperty('image-rendering', v)\n  }\n})\nrenderer.shadowMap.enabled = true\nrenderer.shadowMap.type = PCFShadowMap\nrenderer.outputEncoding = sRGBEncoding\n// renderer.gammaOutput = true\n// renderer.gammaFactor = 2.2\nrenderer.autoClear = false\n\nconst downsample = new NiceParameter(\n  'pixel-down-sample',\n  'Graphics Quality',\n  6,\n  0,\n  10,\n  (v) => v,\n  (v) => v + '',\n  true,\n  RESET_USER_SETTINGS_TO_DEFAULTS,\n  1\n)\n\nlet __downsample = 1\nfunction updatePixelRatio() {\n  const pixelRatio = device.pixelRatio / __downsample\n  devicePixelRatioUniform.value = pixelRatio\n  renderer.setPixelRatio(pixelRatio)\n}\n\ndownsample.listen((downsample) => {\n  __downsample = Math.round(downsample + 1)\n  updatePixelRatio()\n})\n\ndevice.onChange(() => {\n  updatePixelRatio()\n  const { width, height } = device\n  renderer.setSize(width, height)\n  devicePixelRatioUniform.value = device.pixelRatio\n  pixelSizeInClipSpaceUniform.value.set(2 / width, 2 / height)\n}, true)\nexport const maxTextureSize = Math.min(\n  8192,\n  renderer.capabilities.maxTextureSize\n)\n\nexport default renderer\n", "import { Color } from 'three'\n\nimport { hexColor } from './colors'\nimport { clamp } from './math'\n\nexport function getUrlParam(param: string) {\n  __setReminder(param)\n  return new URL(window.location.href).searchParams.get(param)\n}\n\nexport function getUrlFlag(param: string) {\n  const result = getUrlParam(param)\n  return !!(result === '' || (result && result !== 'false'))\n}\n\nfunction __getUrlNumber(\n  param: string,\n  defaultVal: number,\n  parser: (val: string) => number,\n  min = -Infinity,\n  max = Infinity\n) {\n  return clamp(parser(getUrlParam(param) || defaultVal.toString()), min, max)\n}\n\nexport function getUrlFloat(\n  param: string,\n  defaultVal: number,\n  min = -Infinity,\n  max = Infinity\n) {\n  return __getUrlNumber(param, defaultVal, parseFloat, min, max)\n}\n\nexport function getUrlInt(\n  param: string,\n  defaultVal: number,\n  min = -Infinity,\n  max = Infinity\n) {\n  return __getUrlNumber(param, defaultVal, parseInt, min, max)\n}\n\nexport function getUrlColor(param: string, defaultColor: string | Color) {\n  let str = getUrlParam(param)\n  if (!str) {\n    if (defaultColor instanceof Color) {\n      return defaultColor\n    } else {\n      str = defaultColor\n    }\n  }\n  return hexColor('#' + str)\n}\n\nconst __keysToRemember: string[] = []\nlet __reminderQueued = false\nfunction __setReminder(name: string) {\n  if (!__keysToRemember.includes(name)) {\n    __keysToRemember.push(name)\n    if (!__reminderQueued) {\n      __reminderQueued = true\n      setTimeout(() => {\n        console.log('Nice Parameters to try: ' + __keysToRemember.join(', '))\n        __reminderQueued = false\n      }, 2000)\n    }\n  }\n}\n", "import { Color, MeshBasicMaterial } from 'three'\nimport { rand } from '~/utils/math'\n\nconst __whiteColor = new Color(1, 1, 1)\nconst __tempColor = new Color()\n\nexport function addColor(dst: Color, src: Color, amt: number) {\n  if (amt === 0) {\n    return\n  }\n  __tempColor.copy(src).multiplyScalar(amt)\n  dst.add(__tempColor)\n}\n\nexport function screenColor(dst: Color, src: Color) {\n  __tempColor.copy(__whiteColor).sub(dst)\n  dst.add(__tempColor.multiply(src))\n}\n\nexport function createMaterial(col: Color | string | number) {\n  const color = new Color(col)\n  const hsl = { h: 0, s: 0, l: 0 }\n  color.getHSL(hsl)\n  hsl.h += rand(-0.025, 0.025)\n  hsl.s += rand(-0.05, 0.05)\n  hsl.l += rand(-0.05, 0.05)\n  color.setHSL(hsl.h, hsl.s, hsl.l)\n  const mat = new MeshBasicMaterial({\n    color,\n    transparent: true,\n    opacity: 0.2,\n    depthWrite: false\n  })\n  mat.color = color\n  return mat\n}\n\nexport function makeHSL(h: number, s = 0.75, l = 0.5) {\n  return new Color().setHSL(h, s, l)\n}\n\n//color style algorithm extracted from three.js\nexport function hexColor(style: string) {\n  const m = /^#([A-Fa-f0-9]+)$/.exec(style)\n  if (m) {\n    // hex color\n\n    const hex = m[1]\n    const size = hex.length\n\n    if (size === 3) {\n      const color = new Color()\n      // #ff0\n      color.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255\n      color.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255\n      color.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255\n\n      return color\n    } else if (size === 6) {\n      const color = new Color()\n      // #ff0000\n      color.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255\n      color.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255\n      color.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255\n\n      return color\n    }\n  }\n  return new Color(1, 0, 1)\n}\n", "import { Camera, Plane, Ray, Vector3 } from 'three'\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.min(max, Math.max(min, val))\n}\n\nexport function mod(val: number, freq: number) {\n  return ((val % freq) + freq) % freq\n}\n\nexport function wrap(val: number, min: number, max: number) {\n  const range = max - min\n  return ((((val - min) % range) + range) % range) + min\n}\n\nexport function absFloor(val: number) {\n  return Math.floor(Math.abs(val)) * (val < 0 ? -1 : 1)\n}\n\nconst tiny = 0.00001\nexport function closeEnough(val: number, val2: number) {\n  return Math.abs(val - val2) < tiny\n}\n\nexport const TWO_PI = 2 * Math.PI\n\nexport const RADIANS_TO_DEGREES = 180 / Math.PI\n\nexport const DEGREES_TO_RADIANS = Math.PI / 180\n\nexport function radiansToDegrees(radians: number) {\n  return radians * RADIANS_TO_DEGREES\n}\n\nexport function degreesToRadians(degrees: number) {\n  return degrees * DEGREES_TO_RADIANS\n}\n\nconst ray: Ray = new Ray()\nconst flatPlane: Plane = new Plane(new Vector3(0, -1, 0), 1)\nconst anyPlane: Plane = new Plane(new Vector3(0, -1, 0), 1)\nconst intersection: Vector3 = new Vector3()\n\n// const __cameraPosition = new Vector3()\n\nexport function get2DPositionOnPlane(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  plane: Plane\n) {\n  // __cameraPosition.set(0, 0, 0)\n  // camera.localToWorld(__cameraPosition)\n  ray.origin.copy(cameraWorldPos)\n  ray.direction.set(x, y, 0.5).unproject(camera).sub(cameraWorldPos).normalize()\n\n  ray.intersectPlane(plane, intersection)\n  return intersection\n}\nexport function get2DPositionAtDepth(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  atDepth = 0\n) {\n  flatPlane.constant = atDepth\n  return get2DPositionOnPlane(camera, cameraWorldPos, x, y, flatPlane)\n}\nexport function get2DPositionOnPlaneHelper(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  coPlanarPoint: Vector3,\n  normal: Vector3\n) {\n  anyPlane.setFromNormalAndCoplanarPoint(normal, coPlanarPoint)\n  return get2DPositionOnPlane(camera, cameraWorldPos, x, y, anyPlane)\n}\n\nexport function lerp(a: number, b: number, dt: number) {\n  const out = a + dt * (b - a)\n  return Math.abs(b - out) > 0.00001 ? out : b\n}\n\nexport function unlerp(min: number, max: number, value: number) {\n  return (value - min) / (max - min)\n}\n\nexport function unlerpClamped(min: number, max: number, value: number) {\n  return clamp(unlerp(min, max, value), 0, 1)\n}\n\nexport function degreesDifference(A: number, B: number) {\n  return ((((A - B) % 360) + 540) % 360) - 180\n}\n\nconst tau = Math.PI * 2\nconst tauAndHalf = Math.PI * 3\nexport function radiansDifference(a: number, b: number) {\n  return ((((a - b) % tau) + tauAndHalf) % tau) - Math.PI\n}\n\nexport function rand(min = 0, max = 1) {\n  return Math.random() * (max - min) + min\n}\n\nexport function rand2(scale = 1, offset = 0) {\n  return (Math.random() * 2 - 1) * scale + offset\n}\n\nexport function nextHighestPowerOfTwo(val: number) {\n  return Math.pow(Math.ceil(Math.sqrt(val)), 2)\n}\n\nexport function inferDirection(val: number, tolerance = 0.00001) {\n  if (val < -tolerance) {\n    return -1\n  } else if (val > tolerance) {\n    return 1\n  } else {\n    return 0\n  }\n}\n\nexport function sqr(v: number) {\n  return v * v\n}\n\nexport function pixelLengthOnScreen(a: Vector3, b: Vector3, camera: Camera) {\n  a.project(camera)\n  b.project(camera)\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n}\n\nconst phi = (Math.sqrt(5) + 1) * 0.5 - 1\nconst ga = phi * Math.PI * 2\nexport function pointOnSphereFibonacci(\n  index: number,\n  total: number\n): [number, number] {\n  //[long, lat];\n  return [ga * index, Math.asin(-1 + (2 * index) / total)]\n}\n\nexport function longLatToXYZ(\n  longLat: [number, number],\n  radius: number\n): [number, number, number] {\n  const long = longLat[0]\n  const lat = longLat[1]\n  return [\n    Math.cos(lat) * Math.cos(long) * radius,\n    Math.sin(lat) * radius,\n    Math.cos(lat) * Math.sin(long) * radius\n  ]\n}\n\nexport function powerOfTwo(x: number) {\n  return Math.log2(x) % 1 === 0\n}\n\nexport function assertPowerOfTwo(x: number) {\n  if (!powerOfTwo(x)) {\n    throw new Error(`${x} is not a power of two`)\n  }\n}\n", "import { getUrlFlag, getUrlInt } from './utils/location'\n\nexport const RESET_USER_SETTINGS_TO_DEFAULTS = getUrlFlag('resetSettings')\n\nexport const initOffset = {\n  x: getUrlInt('x', 0),\n  y: getUrlInt('y', 0)\n}\n", "type DeviceType = 'mobile' | 'tablet' | 'desktop'\ntype DeviceOrientation = 'landscape' | 'portrait'\n\ntype Listener = () => void\n\nclass Device {\n  width = 1920\n  height = 1080\n  aspect = 1920/1080\n  deviceWidth = 1920 \n  deviceHeight = 1080// landscape orientation\n  deviceAspect = 1920/1080// landscape orientation\n  orientation: DeviceOrientation = 'landscape'\n  pixelRatio = 1\n  targetFPS = 60\n  useTouch = false\n  type: DeviceType = 'desktop'\n  listeners: Set<Listener> = new Set()\n  private cachedPPCm = -1\n\n  constructor() {\n    window.addEventListener('resize', () => {\n      this.handleChange()\n\n      // XXX Fix for IOS homescreen: Need to wait a little bit for the screen to settle\n      setTimeout(this.handleChange, 50)\n    })\n    this.handleChange()\n  }\n\n  handleChange = () => {\n    this.useTouch =\n      /Mobi|Android|iPhone|iPad|BlackBerry|Windows Phone|webOS/i.test(\n        navigator.userAgent\n      )\n\n    if (\n      this.width === window.innerWidth &&\n      this.height === window.innerHeight\n    ) {\n      return\n    }\n\n    this.width = window.innerWidth\n    this.height = window.innerHeight\n    this.aspect = this.width / this.height\n    this.deviceHeight = Math.min(this.width, this.height)\n    this.deviceWidth = Math.max(this.width, this.height)\n    this.deviceAspect = this.deviceWidth / this.deviceHeight\n    this.pixelRatio = window.devicePixelRatio\n    this.orientation = this.aspect < 1 ? 'portrait' : 'landscape'\n    this.type = this.useTouch\n      ? this.deviceWidth < 1024 && this.deviceAspect > 1.6\n        ? 'mobile'\n        : 'tablet'\n      : 'desktop'\n\n    this.listeners.forEach((listener) => listener())\n  }\n\n  onChange(listener: Listener, firstOneForFree = false) {\n    this.listeners.add(listener)\n    if (firstOneForFree) {\n      listener()\n    }\n\n    return () => this.listeners.delete(listener)\n  }\n\n  get isMobile() {\n    return this.type === 'mobile'\n  }\n\n  get isTablet() {\n    return this.type === 'tablet'\n  }\n\n  get isDesktop() {\n    return this.type === 'desktop'\n  }\n\n  get pixelsPerCm() {\n    if (this.cachedPPCm === -1) {\n      // create an empty element\n      const div = document.createElement('div')\n      // give it an absolute size of one inch\n      div.style.height = '1in'\n      // append it to the body\n      const body = document.getElementsByTagName('body')[0]\n      body.appendChild(div)\n      // read the computed width\n      const ppi = getComputedStyle(div, null).getPropertyValue('height')\n      // remove it again\n      body.removeChild(div)\n      // and return the value\n      this.cachedPPCm = parseFloat(ppi) * 2.54\n    }\n    return this.cachedPPCm\n  }\n\n  get screenHeightCms() {\n    return this.height / this.pixelsPerCm\n  }\n\n  get screenWidthCms() {\n    return this.width / this.pixelsPerCm\n  }\n\n  get screenShorterCms() {\n    return Math.min(this.width, this.height) / this.pixelsPerCm\n  }\n\n  setFPS(fps = 60) {\n    this.targetFPS = fps\n  }\n}\n\nconst device = new Device()\n;(window as any).device = device\n\nexport default device\n", "import { Uniform, Vector2 } from 'three'\n\nimport device from './device'\n\nexport const timeUniform = new Uniform(0.0)\n\nexport const devicePixelRatioUniform = new Uniform(device.pixelRatio)\nexport const pixelSizeInClipSpaceUniform = new Uniform(\n  new Vector2(2 / device.width, 2 / device.height)\n)\nexport const pixelAspectRatioUniform = new Uniform(device.width / device.height)\ndevice.onChange(() => {\n  pixelAspectRatioUniform.value = device.width / device.height\n})\n", "import { absFloor, clamp } from './math'\nexport const scaleValuesInArray = (arr: number[], scale: number) => {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] *= scale\n  }\n}\n\nexport const addToArrayUnique = <T>(arr: T[], value: T) => {\n  const index = arr.indexOf(value)\n  if (index === -1) {\n    arr.push(value)\n  }\n}\n\nexport const removeFromArray = <T>(arr: T[], value: T, strict = false) => {\n  const index = arr.indexOf(value)\n  if (index !== -1) {\n    arr.splice(index, 1)\n  } else if (strict) {\n    throw new Error('could not find value in array')\n  }\n  return value\n}\n\nexport const moveBetweenArrays = <T>(src: T[], dst: T[], value: T) => {\n  dst.push(removeFromArray(src, value))\n  return value\n}\n\nexport const replaceManyInArray = <T>(\n  arr: Array<T | undefined>,\n  value: T,\n  replacement?: T\n) => {\n  if (value === replacement) {\n    throw new Error('Nope. This would cause an infinite loop')\n  }\n  let index = arr.indexOf(value)\n  while (index !== -1) {\n    arr[index] = replacement\n    index = arr.indexOf(value)\n  }\n}\n\nexport function getArrayDiffs<T>(oldArr: T[], newArr: T[]) {\n  const added = newArr.filter((item) => !oldArr.includes(item))\n\n  const removed = oldArr.filter((item) => !newArr.includes(item))\n\n  const equal = newArr.filter((item) => oldArr.includes(item))\n\n  return {\n    added,\n    removed,\n    equal\n  }\n}\n\nexport const pushToArrayMap = <T, T2>(\n  map: Map<T, T2[]>,\n  key: T,\n  value: T2,\n  oneCopyMax = false\n) => {\n  if (!map.has(key)) {\n    map.set(key, [])\n  }\n  const arr = map.get(key) as T2[]\n  if (arr) {\n    if (oneCopyMax) {\n      if (arr.indexOf(value) === -1) {\n        arr.push(value)\n      }\n    } else {\n      arr.push(value)\n    }\n  }\n}\n\nexport const cleanRemoveFromArrayMap = <T, T2>(\n  map: Map<T, T2[]>,\n  key: T,\n  value: T2\n) => {\n  if (!map.has(key)) {\n    return\n  }\n  const arr = map.get(key) as T2[]\n  if (arr) {\n    removeFromArray(arr, value)\n    if (arr.length === 0) {\n      map.delete(key)\n    }\n  }\n}\n\nfunction signMatches(val: number, val2: number) {\n  return val >= 0 === val2 >= 0\n}\n//binary search only works assuming numbers have been sorted from lowest to highest\nexport function findClosestNumberIndex(arr: number[], value: number): number {\n  const middleIndex = ~~(arr.length * 0.5)\n  let step = value > arr[middleIndex] ? 1 : -1\n  let index = middleIndex\n  let oldSample = arr[index]\n  let everTurned = false\n  let limit = 100\n  while (step !== 0 && limit > 0) {\n    index = clamp(index + step, 0, arr.length - 1)\n    const newSample = arr[index]\n    if (!signMatches(value - newSample, value - oldSample)) {\n      step *= -1\n      everTurned = true\n    }\n    step = absFloor(step * (everTurned ? 0.5 : 2))\n    oldSample = newSample\n    limit--\n  }\n  return index\n}\n\nexport function getArrWrap<T>(arr: T[], i: number) {\n  const t = arr.length\n  return arr[((i % t) + t) % t]\n}\n\nexport function getArrNext<T>(arr: T[], item: T) {\n  return getArrWrap(arr, arr.indexOf(item) + 1)\n}\n\nexport function getArrPrev<T>(arr: T[], item: T) {\n  return getArrWrap(arr, arr.indexOf(item) - 1)\n}\n\nexport function getArrAround<T>(arr: T[], item: T) {\n  const i = arr.indexOf(item)\n  return [getArrWrap(arr, i - 1), item, getArrWrap(arr, i + 1)]\n}\n", "import { Color, Vector3 } from 'three'\n\nimport { hexColor } from './colors'\nimport { clamp } from './math'\n\nexport function getLocalStorageParam(key: string) {\n  return localStorage.getItem(key)\n}\n\nexport function setLocalStorageParam(key: string, val: string) {\n  return localStorage.setItem(key, val)\n}\n\nexport function getLocalStorageFlag(key: string) {\n  const result = getLocalStorageParam(key)\n  return !!(result === '' || (result && result !== 'false'))\n}\n\nexport function setLocalStorageFlag(key: string, val: boolean) {\n  setLocalStorageParam(key, val ? 'true' : 'false')\n}\n\nfunction __getLocalStorageNumber(\n  key: string,\n  defaultVal: number,\n  parser: (val: string) => number,\n  min = -Infinity,\n  max = Infinity\n) {\n  return clamp(\n    parser(getLocalStorageParam(key) || defaultVal.toString()),\n    min,\n    max\n  )\n}\n\nfunction __setLocalStorageNumber(key: string, val: number) {\n  return setLocalStorageParam(key, val.toString())\n}\n\nexport function getLocalStorageFloat(\n  key: string,\n  defaultVal: number,\n  min = -Infinity,\n  max = Infinity\n) {\n  return __getLocalStorageNumber(key, defaultVal, parseFloat, min, max)\n}\nexport function setLocalStorageFloat(key: string, val: number) {\n  return __setLocalStorageNumber(key, val)\n}\n\nexport function getLocalStorageInt(\n  key: string,\n  defaultVal: number,\n  min = -Infinity,\n  max = Infinity\n) {\n  return __getLocalStorageNumber(key, defaultVal, parseInt, min, max)\n}\nexport function setLocalStorageInt(key: string, val: number) {\n  return __setLocalStorageNumber(key, val)\n}\n\nexport function getLocalStorageColor(key: string, defaultColor: string) {\n  let str = getLocalStorageParam(key)\n  if (!str) {\n    str = defaultColor\n  }\n  return hexColor('#' + str)\n}\n\nexport function setLocalStorageColor(key: string, color: Color) {\n  setLocalStorageParam(key, color.getHexString())\n}\n\nexport function getLocalStorageVec3(\n  key: string,\n  defX = 0,\n  defY = 0,\n  defZ = 0,\n  min = -Infinity,\n  max = Infinity\n) {\n  const x = getLocalStorageFloat(key + '.x', defX, min, max)\n  const y = getLocalStorageFloat(key + '.y', defY, min, max)\n  const z = getLocalStorageFloat(key + '.z', defZ, min, max)\n  return new Vector3(x, y, z)\n}\n\nexport function setLocalStorageVec3(key: string, val: Vector3) {\n  setLocalStorageFloat(key + '.x', val.x)\n  setLocalStorageFloat(key + '.y', val.y)\n  setLocalStorageFloat(key + '.z', val.z)\n}\n", "import { removeFromArray } from './arrayUtils'\nimport { getLocalStorageFloat } from './localStorage'\nimport { getUrlFloat } from './location'\nimport { clamp } from './math'\n\nexport const niceParameters: NiceParameter[] = []\n\ntype Listener = (value: number) => void\n\nexport class NiceParameter {\n  name: string\n  label: string\n  defaultValue: number\n  minValue: number\n  maxValue: number\n  step: number\n  sliderOrderPriority: number\n  distribution: (value: number) => number\n  valueTextConverter: (value: number) => string\n  private _availableToUserMethod: () => boolean\n  private _value: number\n  private _listeners: Listener[]\n  constructor(\n    name: string,\n    label: string,\n    defaultValue: number,\n    minValue: number,\n    maxValue: number,\n    distribution: (value: number) => number,\n    valueTextConverter: (value: number) => string,\n    availableToUser: (() => boolean) | boolean,\n    forceDefault = false,\n    step = 0.01,\n    sliderOrderPriority = 0\n  ) {\n    this.name = name\n    this.label = label\n    this.defaultValue = defaultValue\n    this.minValue = minValue\n    this.maxValue = maxValue\n    this.step = step\n    this.distribution = distribution\n    this.valueTextConverter = valueTextConverter\n    this._availableToUserMethod =\n      availableToUser === true || availableToUser === false\n        ? () => availableToUser\n        : availableToUser\n    this._listeners = []\n    if (forceDefault) {\n      this.value = this.defaultValue\n    }\n    this._value = getLocalStorageFloat(\n      'nice-param-' + name,\n      defaultValue,\n      minValue,\n      maxValue\n    )\n    const urlVal = getUrlFloat(name, this._value, minValue, maxValue)\n    if (urlVal !== this._value) {\n      this.value = urlVal\n    }\n    niceParameters.push(this)\n    if (sliderOrderPriority === 0) {\n      sliderOrderPriority = niceParameters.length\n    }\n    this.sliderOrderPriority = sliderOrderPriority\n  }\n\n  listen(callback: Listener) {\n    this._listeners.push(callback)\n    callback(this.value)\n  }\n\n  stopListening(callback: Listener) {\n    removeFromArray(this._listeners, callback)\n  }\n\n  set value(val: number) {\n    if (val === this._value) {\n      return\n    }\n    val = clamp(val, this.minValue, this.maxValue)\n    if (val === this._value) {\n      return\n    }\n    this._value = val\n    localStorage.setItem('nice-param-' + this.name, String(val))\n    this._listeners.forEach((cb) => cb(val))\n  }\n\n  get value() {\n    return this._value\n  }\n\n  get availableToUser() {\n    return this._availableToUserMethod()\n  }\n}\n", "import { Euler, PerspectiveCamera } from 'three'\nimport device from '~/device'\nimport { clamp } from '~/utils/math'\n\nconst SHAKE_CHANGE_DURATION = 0.1\nconst LOW_HERTZ = 200\nconst HIGH_HERTZ = 6000\n\nconst FOV = 35\nconst MOBILE_FOV = 28\n\nclass CameraShaker {\n  private set shakeStrength(value: number) {\n    value = clamp(value, 0, 1)\n    if (value === this._shakeStrength) {\n      return\n    }\n    this._shakeStrength = value\n  }\n  set shakeScale(value: number) {\n    value = clamp(value, 0, 10)\n    if (value === this._shakeScale) {\n      return\n    }\n    this._shakeScale = value\n  }\n  shakyCamera: PerspectiveCamera\n  private _time: number\n  private _timers: number[]\n  private _shakeStrength: number\n  private _shakeScale: number\n  constructor(public camera: PerspectiveCamera) {\n    this._time = 0\n    this._timers = []\n    this._shakeScale = 0.00025\n    this._shakeStrength = 0\n    const shakyCamera = camera.clone()\n    shakyCamera.position.set(0, 0, 0)\n    shakyCamera.quaternion.setFromEuler(new Euler(0, 0, 0))\n    shakyCamera.scale.set(1, 1, 1)\n    camera.add(shakyCamera)\n    this.shakyCamera = shakyCamera\n  }\n  updateProjection() {\n    this.shakyCamera.fov = this.camera.fov\n    this.shakyCamera.aspect = this.camera.aspect\n    this.shakyCamera.updateProjectionMatrix()\n  }\n  update(dt: number) {\n    this._time += dt\n    this.shakeStrength =\n      this._shakeStrength +\n      (dt / SHAKE_CHANGE_DURATION) * (this._timers.length > 0 ? 12 : -1)\n    if (this._shakeStrength > 0) {\n      this.shakyCamera.position.set(0, 0, 0)\n      let octave = 1\n      for (let i = LOW_HERTZ; i < HIGH_HERTZ; i *= 1.674, octave *= 0.8) {\n        const overallStrength =\n          (1 / octave) * this._shakeScale * this._shakeStrength\n        this.shakyCamera.position.x +=\n          Math.sin(this._time * i) * overallStrength\n        this.shakyCamera.position.y +=\n          Math.sin(this._time * i * 1.235) * overallStrength\n        this.shakyCamera.position.z +=\n          Math.sin(this._time * i * 1.67235) * overallStrength\n      }\n    }\n    while (this._timers.length > 0 && this._timers[0] <= this._time) {\n      this._timers.shift()\n    }\n  }\n  add(duration: number) {\n    this._timers.push(this._time + duration)\n    this._timers.sort()\n  }\n}\n\nconst camera = new PerspectiveCamera(\n  device.isMobile ? MOBILE_FOV : FOV,\n  device.aspect,\n  0.01,\n  10\n)\n\nexport const cameraShaker = new CameraShaker(camera)\n\ndevice.onChange(() => {\n  camera.fov = device.isMobile ? MOBILE_FOV : FOV\n  camera.aspect = device.aspect\n  camera.updateProjectionMatrix()\n  cameraShaker.updateProjection()\n})\n", "import { removeFromArray } from '~/utils/arrayUtils'\n\ntype UpdateCallback = (dt: number) => void\n\ninterface Updater {\n  update: UpdateCallback\n}\n\nconst updaters: Updater[] = []\nconst update = (dt: number) => {\n  for (const updater of updaters) {\n    updater.update(dt)\n  }\n}\n\nconst register = (sib: Updater) => {\n  updaters.push(sib)\n}\n\nconst unregister = (sib: Updater) => {\n  removeFromArray(updaters, sib)\n}\n\nconst UpdateManager = {\n  update,\n  register,\n  unregister\n}\n\nexport default UpdateManager\n", "import {\n  Camera,\n  Color,\n  Fog,\n  PerspectiveCamera,\n  Scene,\n  WebGLRenderer\n} from 'three'\nimport device from '~/device'\nimport { getUrlColor } from '~/utils/location'\n\nconst FOV = 35\nconst MOBILE_FOV = 28\nexport class BaseTestScene {\n  autoClear = true\n  protected scene: Scene\n  protected camera: Camera\n  protected bgColor: Color\n  constructor() {\n    const scene = new Scene()\n\n    const bgColor: Color = getUrlColor('bgColor', new Color(0x6f84bc))\n    scene.fog = new Fog(bgColor.getHex(), 0, 60)\n    scene.autoUpdate = false\n    scene.matrixAutoUpdate = false\n    scene.frustumCulled = true\n\n    const camera = new PerspectiveCamera(\n      device.isMobile ? MOBILE_FOV : FOV,\n      device.aspect,\n      0.1,\n      100\n    )\n    camera.position.set(0, 2, 2)\n    camera.lookAt(0, 0, 0)\n    scene.add(camera)\n\n    device.onChange(() => {\n      camera.fov = device.isMobile ? MOBILE_FOV : FOV\n      camera.aspect = device.aspect\n      camera.updateProjectionMatrix()\n    }, true)\n\n    this.scene = scene\n    this.camera = camera\n    this.bgColor = bgColor\n    this.scene.background = this.bgColor\n  }\n\n  update(dt: number) {\n    this.scene.updateMatrixWorld(false)\n  }\n\n  render(renderer: WebGLRenderer, dt: number) {\n    if (this.autoClear && !renderer.autoClear) {\n      renderer.setClearColor(this.bgColor, 1)\n      renderer.clear(true, true, true)\n    }\n    renderer.render(this.scene, this.camera)\n  }\n}\n", "import { Color, PerspectiveCamera, WebGLRenderer } from 'three'\nimport PixelTextMesh from '@lib/index'\nimport { loadText } from '~/loaders/assetLoader'\nimport PixelFontFace from '@lib/PixelFontFace'\nimport { PixelTextSettings } from '@lib/PixelTextSettings'\nimport { pixelSizeInClipSpaceUniform } from '~/uniforms'\nimport { FPSControls } from '~/utils/fpsControls'\nimport { getUrlFlag } from '~/utils/location'\nimport { rand2 } from '~/utils/math'\n\nimport { BaseTestScene } from './BaseTestScene'\n\nfunction url(name: string, ext: string) {\n  return `books/${name}.${ext}`\n}\n\nexport default class TestManyLabelsScene extends BaseTestScene {\n  constructor() {\n    super()\n    this.camera.position.set(0, 0, 0.5)\n    this.camera.lookAt(0, 0, 0)\n    // this.camera.updateProjectionMatrix()\n    const fps = new FPSControls(this.camera as PerspectiveCamera)\n    if (getUrlFlag('fpsCam')) {\n      fps.toggle(true)\n    }\n\n    // const s = 1\n\n    // const hello = new PixelTextMesh(' ABC \\n 010 \\n ntz \\n \"#% \\n { } \\n0ANan')\n    // // const hello = new PixelTextMesh('This is the beginning!\\nHello World!\\nHello World!\\nHello World!\\nHello World!')\n    // hello.scale.multiplyScalar(s)\n    // this.scene.add(hello)\n\n    const init = async () => {\n      let bookText = 'Hello world.'\n      // bookText = '1.0\\n1.0.3\\n1.0.31\\n1.0.3 1\\n1 .0.3 1\\n-.-.E.E-E'\n      // bookText = '\u00A9 Tomasz Dysinski. Here & now.'\n\n      bookText = await await loadText(url('augustine-confessions-276', 'txt'))\n      bookText = bookText.replace(/[^\\w\\s\\']|_/g, \"\")\n         .replace(/\\s+/g, \" \");\n\n         bookText = bookText.replace(/[0-9]/g, '');\n         bookText = bookText.toLowerCase()\n\n         bookText = bookText.replace(/['\"]+/g, '')\n         \n      const labelStrings = bookText\n        // .slice(0, 10000)\n        .split('\\n')\n        .join(' ')\n        .split(' ')\n        .filter((v) => !!v)\n\n      const uniqueWords = new Set(labelStrings)\n\n      console.log(labelStrings.length)\n      console.log(uniqueWords.size)\n      const uniqueLabelStrings = Array.from(uniqueWords.values()).slice(0, 1000)\n      const options: PixelTextSettings = {\n        align: 0.5,\n        vAlign: 0.5,\n        // fontFace: new PixelFontFace('pixelFonts/cdogs_font_7x8', 7, 8),\n        fontFace: new PixelFontFace('pixelFonts/good_neighbors', 11, 16),\n        color: new Color(1, 1, 1),\n        letterSpacing: -1,\n        strokeColor: new Color(0, 0, 0),\n        scaleDownToPhysicalSize: true,\n        screenSpace: true,\n        constantSizeOnScreen: false,\n        pixelSizeInClipSpaceUniform: pixelSizeInClipSpaceUniform,\n        prescale: 10\n      }\n      for (const labelString of uniqueLabelStrings) {\n        const label = new PixelTextMesh(\n          labelString,\n          options,\n          undefined,\n          (w, h) => {\n            label.scale.x = 0.01 * w\n            label.scale.y = 0.01 * h\n          }\n        )\n        label.position\n          .set(rand2(1), rand2(1), rand2(1))\n          .normalize()\n          .multiplyScalar(0.3)\n        this.scene.add(label)\n      }\n    }\n    init()\n  }\n  update(dt: number) {\n    super.update(dt)\n  }\n  render(renderer: WebGLRenderer, dt: number) {\n    super.render(renderer, dt)\n  }\n}\n", "import TestManyLabelsScene from './helpers/scenes/TestManyLabelsScene'\nimport TestPixelTextScene from './helpers/scenes/TestPixelText'\n\nexport const testClasses: { [K: string]: any } = {\n  pixelText: TestPixelTextScene,\n  manyLabels: TestManyLabelsScene\n}\n", "const callbacks: Array<() => void> = []\n\nexport function nextFrameUpdate() {\n  if (callbacks.length > 0) {\n    callbacks.forEach((cb) => cb())\n    callbacks.length = 0\n  }\n}\n\nexport function onNextFrame(callback: () => void) {\n  callbacks.push(callback)\n}\n"],
  "mappings": "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",
  "names": []
}

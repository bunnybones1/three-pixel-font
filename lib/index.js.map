{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils/math.ts", "../src/utils/arrayUtils.ts", "../src/utils/propertyListeners.ts", "../src/utils/threeUtils.ts"],
  "sourcesContent": ["import {\n  BufferGeometry,\n  Camera,\n  Color,\n  DataTexture,\n  Group,\n  IUniform,\n  Material,\n  Matrix4,\n  Mesh,\n  NearestFilter,\n  PlaneBufferGeometry,\n  RGBAFormat,\n  RepeatWrapping,\n  Scene,\n  ShaderMaterial,\n  Texture,\n  Uniform,\n  UnsignedByteType,\n  UVMapping,\n  Vector2,\n  Vector4,\n  WebGLRenderer,\n  RawShaderMaterial\n} from 'three'\nimport {\n  listenToProperty,\n  stopListeningToProperty\n} from './utils/propertyListeners'\nimport { getTempTexture } from './utils/threeUtils'\n\nimport fragmentShader from './frag.glsl'\nimport PixelFontFace from './PixelFontFace'\nimport { pixelTextSettings, PixelTextSettings } from './PixelTextSettings'\nimport vertexShader from './vert.glsl'\n\nconst __mat = new Matrix4()\n\nconst trackedFontFaceTextures: Texture[] = []\nfunction getFontFaceSubOrder(texture?: Texture) {\n  if (!texture) {\n    return -1\n  }\n  const index = trackedFontFaceTextures.indexOf(texture)\n  if (index === -1) {\n    trackedFontFaceTextures.push(texture)\n    return trackedFontFaceTextures.length - 1\n  } else {\n    return index\n  }\n}\n\nconst MAX_LINES = 2048\n\nexport default class PixelTextMesh extends Mesh {\n  width = 0\n  height = 0\n\n  dirty = false\n  livePropObject?: object\n  livePropName?: string\n\n  private _fontFace: PixelFontFace | undefined\n  private _newTexture?: Texture\n  private _newFontString?: string\n\n  constructor(\n    private _text = '',\n    public settings: PixelTextSettings = pixelTextSettings.generic,\n    public onMeasurementsUpdated?: (mesh: PixelTextMesh) => void,\n    public onCharSizeUpdated?: (width: number, height: number) => void,\n    public optimizeRenderOrder = true\n  ) {\n    super(getTextGeometry(_text, settings), initMaterial(settings))\n\n    listenToProperty(settings, 'fontFace', this.onFontFaceChange, true)\n  }\n\n  get text() {\n    return this._text\n  }\n\n  set text(text: string) {\n    if (this._text !== text) {\n      this._text = text\n      this.dirty = true\n    }\n  }\n\n  onFontFaceChange = (\n    newFontFace: PixelFontFace,\n    oldFontFace: PixelFontFace\n  ) => {\n    if (oldFontFace) {\n      stopListeningToProperty(oldFontFace, 'texture', this.onFontTextureUpdate)\n      stopListeningToProperty(oldFontFace, 'font', this.onFontUpdate)\n    }\n    listenToProperty(newFontFace, 'texture', this.onFontTextureUpdate)\n    listenToProperty(newFontFace, 'font', this.onFontUpdate)\n\n    newFontFace.init()\n    this._fontFace = newFontFace\n  }\n\n  onFontTextureUpdate = (texture: Texture) => {\n    this._newTexture = texture\n    this.dirty = true\n  }\n\n  onFontUpdate = (fontString: string) => {\n    this._newFontString = fontString\n    this.dirty = true\n  }\n\n  onBeforeRender = (\n    renderer: WebGLRenderer,\n    scene: Scene,\n    camera: Camera,\n    geometry: BufferGeometry,\n    material: Material,\n    group: Group\n  ) => {\n    if (this.settings.screenSpace) {\n      const clipPos = (this.material as ShaderMaterial)!.uniforms\n        .clipSpacePosition.value as Vector4\n      __mat\n        .multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld)\n        .premultiply(camera.projectionMatrix)\n      //.multiply(camera.projectionMatrix)\n      clipPos.set(0, 0, 0, 1).applyMatrix4(__mat)\n    }\n    if (this.dirty) {\n      this.dirty = false\n      this.regenerateGeometry()\n      const m = this.material as ShaderMaterial\n      if (this._newTexture) {\n        if (this.optimizeRenderOrder) {\n          this.renderOrder =\n            this.renderOrder || 100 + getFontFaceSubOrder(this._newTexture)\n        }\n        m.uniforms.fontTexture.value = this._newTexture\n        this._newTexture = undefined\n      }\n      if (this._newFontString && this._text) {\n        const lines = this.text.split('\\n').slice(0, MAX_LINES)\n        const charsHeight = lines.length\n\n        const fontSettings = this.settings.fontFace\n        const maxWidthOfChar = fontSettings.maxCharPixelWidth\n        const fontString = fontSettings.font!\n        const charPixelWidths = fontSettings.pixelWidths!\n\n        const overlapPixels = -this.settings.letterSpacing\n\n        const image = (m.uniforms.fontTexture.value as Texture).image\n        m.uniforms.fontSizeInChars.value.set(\n          image.width / fontSettings.maxCharPixelWidth,\n          image.height / fontSettings.charPixelHeight\n        )\n\n        const missingCharIndex = fontString.indexOf('\u25A1')\n        if (missingCharIndex === -1) {\n          throw new Error(\n            'Please include this character \u25A1 in your font, to stand in for other missing characters'\n          )\n        }\n\n        let missingChars = ''\n\n        const linePixelWidths = lines.map((lineString) => {\n          let pixelLength = 0\n          for (let i = 0; i < lineString.length; i++) {\n            const char = lineString[i]\n            if (char == undefined) {\n              continue\n            }\n            const charIndex = fontString.indexOf(char)\n            if (charIndex === -1) {\n              pixelLength +=\n                maxWidthOfChar -\n                charPixelWidths[missingCharIndex] -\n                overlapPixels\n              if (!missingChars.includes(char)) {\n                missingChars += char\n              }\n            } else {\n              pixelLength +=\n                maxWidthOfChar - charPixelWidths[charIndex] - overlapPixels\n            }\n          }\n          return pixelLength + overlapPixels\n        })\n\n        console.warn('Characters in text not found in font: ' + missingChars)\n\n        const maxPixelWidth = linePixelWidths.reduce(\n          (p, c) => Math.max(p, c),\n          0\n        )\n\n        const total = maxPixelWidth * charsHeight\n        const data = new Uint8Array(total * 4)\n\n        for (let iy = 0; iy < charsHeight; iy++) {\n          const lineOffset = iy * maxPixelWidth\n          let xCursor = 0\n          const line = lines[iy]\n          const charsWidth = line.length\n          for (let ix = 0; ix <= charsWidth; ix++) {\n            const char = line[ix]\n            const prevChar = line[ix - 1]\n            if (!char && !prevChar) {\n              continue\n            }\n            let charIndex = fontString.indexOf(char)\n            if (charIndex === -1 && char !== undefined) {\n              charIndex = missingCharIndex\n            }\n            const charPixelWidth = maxWidthOfChar - charPixelWidths[charIndex]\n            for (let ipx = 0; ipx < charPixelWidth; ipx++) {\n              const index = (lineOffset + xCursor) * 4\n              data[index] = charIndex\n              data[index + 1] = (((xCursor - ipx) / maxWidthOfChar) % 1) * 255\n              xCursor++\n            }\n\n            //back up to overlap chars\n            xCursor -= overlapPixels\n            for (let i = 0; i < overlapPixels; i++) {\n              const index = (lineOffset + xCursor + i) * 4\n              data[index + 2] = data[index]\n              data[index + 3] = data[index + 1]\n            }\n          }\n        }\n        m.uniforms.layoutSizeInChars.value.set(\n          maxPixelWidth / maxWidthOfChar,\n          charsHeight\n        )\n        m.uniforms.layoutSizeInCharColumns.value.set(maxPixelWidth, charsHeight)\n        m.uniforms.layoutTexture.value = new DataTexture(\n          data,\n          maxPixelWidth,\n          charsHeight,\n          RGBAFormat,\n          UnsignedByteType,\n          UVMapping,\n          RepeatWrapping,\n          RepeatWrapping,\n          NearestFilter,\n          NearestFilter\n        )\n        this._newFontString = undefined\n        if (this.onCharSizeUpdated) {\n          this.onCharSizeUpdated(maxPixelWidth / maxWidthOfChar, charsHeight)\n        }\n      }\n    }\n  }\n\n  updateText = (value: any = '') => {\n    this.text = `${value}`\n  }\n\n  onRemove() {\n    stopListeningToProperty(this.settings, 'fontFace', this.onFontFaceChange)\n    if (this._fontFace) {\n      stopListeningToProperty(\n        this._fontFace,\n        'texture',\n        this.onFontTextureUpdate\n      )\n      stopListeningToProperty(this._fontFace, 'font', this.onFontUpdate)\n    }\n  }\n\n  private regenerateGeometry() {\n    this.geometry = getTextGeometry(this._text, this.settings)\n    this.updateMeasurements()\n  }\n\n  private updateMeasurements() {\n    const bb = this.geometry.boundingBox!\n    this.width = bb.max.x - bb.min.x\n    this.height = Math.abs(bb.max.y - bb.min.y)\n    this.userData.resolution = new Vector2(this.width, this.height)\n    if (this.onMeasurementsUpdated) {\n      this.onMeasurementsUpdated(this)\n    }\n  }\n}\n\ninterface TextShaderUniforms {\n  fontTexture: IUniform<Texture>\n  layoutTexture: IUniform<Texture>\n  color: IUniform<Color>\n  strokeColor: IUniform<Color>\n  clipSpacePosition?: IUniform<Vector4>\n  pixelSizeInClipSpace?: IUniform<Vector2>\n  prescale?: IUniform<number>\n  alignment?: IUniform<Vector2>\n}\n\nconst initMaterial = (settings: PixelTextSettings) => {\n  const uniforms = {\n    layoutTexture: new Uniform(getTempTexture()),\n    fontTexture: new Uniform(settings.fontFace.texture),\n    color: new Uniform(new Color(settings.color)),\n    strokeColor: new Uniform(new Color(settings.strokeColor)),\n    fontSizeInChars: new Uniform(new Vector2(1, 1)),\n    layoutSizeInChars: new Uniform(new Vector2(1, 1)),\n    layoutSizeInCharColumns: new Uniform(new Vector2(1, 1)),\n    alignment: new Uniform(new Vector2(settings.align, -settings.vAlign))\n  }\n  const safeUniforms: TextShaderUniforms = uniforms\n\n  if (settings.screenSpace) {\n    safeUniforms.prescale = new Uniform(settings.prescale)\n    safeUniforms.clipSpacePosition = new Uniform(new Vector4())\n    if (settings.pixelSizeInClipSpaceUniform) {\n      safeUniforms.pixelSizeInClipSpace = settings.pixelSizeInClipSpaceUniform\n    } else {\n      throw new Error(\n        'You must provide a pixelSizeInClipSpaceUniform for screenSpace mode'\n      )\n    }\n  }\n\n  const material = new RawShaderMaterial({\n    defines: {\n      USE_SCREENSPACE: settings.screenSpace,\n      CONSTANT_SIZE_ON_SCREEN: settings.constantSizeOnScreen\n    },\n    uniforms,\n    vertexShader,\n    fragmentShader,\n    depthWrite: true\n  })\n\n  return material\n}\n\nconst tempBlankGeo = new PlaneBufferGeometry(0.001, 0.001)\ntempBlankGeo.computeBoundingBox()\nconst textGeo = new PlaneBufferGeometry(1, 1)\nconst attr = textGeo.attributes.position\nconst arr = attr.array as number[]\nfor (let i = 0; i < attr.count; i++) {\n  const i3 = i * 3\n  arr[i3] += 0.5\n  arr[i3 + 1] -= 0.5\n}\ntextGeo.computeBoundingBox()\n\nconst getTextGeometry = (\n  text: string,\n  settings: PixelTextSettings\n): BufferGeometry => {\n  if (settings.fontFace.font && text) {\n    return textGeo\n  } else {\n    return tempBlankGeo\n  }\n}\n", "import { Camera, Plane, Ray, Vector3 } from 'three'\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.min(max, Math.max(min, val))\n}\n\nexport function mod(val: number, freq: number) {\n  return ((val % freq) + freq) % freq\n}\n\nexport function wrap(val: number, min: number, max: number) {\n  const range = max - min\n  return ((((val - min) % range) + range) % range) + min\n}\n\nexport function absFloor(val: number) {\n  return Math.floor(Math.abs(val)) * (val < 0 ? -1 : 1)\n}\n\nconst tiny = 0.00001\nexport function closeEnough(val: number, val2: number) {\n  return Math.abs(val - val2) < tiny\n}\n\nexport const TWO_PI = 2 * Math.PI\n\nexport const RADIANS_TO_DEGREES = 180 / Math.PI\n\nexport const DEGREES_TO_RADIANS = Math.PI / 180\n\nexport function radiansToDegrees(radians: number) {\n  return radians * RADIANS_TO_DEGREES\n}\n\nexport function degreesToRadians(degrees: number) {\n  return degrees * DEGREES_TO_RADIANS\n}\n\nconst ray: Ray = new Ray()\nconst flatPlane: Plane = new Plane(new Vector3(0, -1, 0), 1)\nconst anyPlane: Plane = new Plane(new Vector3(0, -1, 0), 1)\nconst intersection: Vector3 = new Vector3()\n\n// const __cameraPosition = new Vector3()\n\nexport function get2DPositionOnPlane(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  plane: Plane\n) {\n  // __cameraPosition.set(0, 0, 0)\n  // camera.localToWorld(__cameraPosition)\n  ray.origin.copy(cameraWorldPos)\n  ray.direction.set(x, y, 0.5).unproject(camera).sub(cameraWorldPos).normalize()\n\n  ray.intersectPlane(plane, intersection)\n  return intersection\n}\nexport function get2DPositionAtDepth(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  atDepth = 0\n) {\n  flatPlane.constant = atDepth\n  return get2DPositionOnPlane(camera, cameraWorldPos, x, y, flatPlane)\n}\nexport function get2DPositionOnPlaneHelper(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  coPlanarPoint: Vector3,\n  normal: Vector3\n) {\n  anyPlane.setFromNormalAndCoplanarPoint(normal, coPlanarPoint)\n  return get2DPositionOnPlane(camera, cameraWorldPos, x, y, anyPlane)\n}\n\nexport function lerp(a: number, b: number, dt: number) {\n  const out = a + dt * (b - a)\n  return Math.abs(b - out) > 0.00001 ? out : b\n}\n\nexport function unlerp(min: number, max: number, value: number) {\n  return (value - min) / (max - min)\n}\n\nexport function unlerpClamped(min: number, max: number, value: number) {\n  return clamp(unlerp(min, max, value), 0, 1)\n}\n\nexport function degreesDifference(A: number, B: number) {\n  return ((((A - B) % 360) + 540) % 360) - 180\n}\n\nconst tau = Math.PI * 2\nconst tauAndHalf = Math.PI * 3\nexport function radiansDifference(a: number, b: number) {\n  return ((((a - b) % tau) + tauAndHalf) % tau) - Math.PI\n}\n\nexport function rand(min = 0, max = 1) {\n  return Math.random() * (max - min) + min\n}\n\nexport function rand2(scale = 1, offset = 0) {\n  return (Math.random() * 2 - 1) * scale + offset\n}\n\nexport function nextHighestPowerOfTwo(val: number) {\n  return Math.pow(Math.ceil(Math.sqrt(val)), 2)\n}\n\nexport function inferDirection(val: number, tolerance = 0.00001) {\n  if (val < -tolerance) {\n    return -1\n  } else if (val > tolerance) {\n    return 1\n  } else {\n    return 0\n  }\n}\n\nexport function sqr(v: number) {\n  return v * v\n}\n\nexport function pixelLengthOnScreen(a: Vector3, b: Vector3, camera: Camera) {\n  a.project(camera)\n  b.project(camera)\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n}\n\nconst phi = (Math.sqrt(5) + 1) * 0.5 - 1\nconst ga = phi * Math.PI * 2\nexport function pointOnSphereFibonacci(\n  index: number,\n  total: number\n): [number, number] {\n  //[long, lat];\n  return [ga * index, Math.asin(-1 + (2 * index) / total)]\n}\n\nexport function longLatToXYZ(\n  longLat: [number, number],\n  radius: number\n): [number, number, number] {\n  const long = longLat[0]\n  const lat = longLat[1]\n  return [\n    Math.cos(lat) * Math.cos(long) * radius,\n    Math.sin(lat) * radius,\n    Math.cos(lat) * Math.sin(long) * radius\n  ]\n}\n\nexport function powerOfTwo(x: number) {\n  return Math.log2(x) % 1 === 0\n}\n\nexport function assertPowerOfTwo(x: number) {\n  if (!powerOfTwo(x)) {\n    throw new Error(`${x} is not a power of two`)\n  }\n}\n", "import { absFloor, clamp } from './math'\nexport const scaleValuesInArray = (arr: number[], scale: number) => {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] *= scale\n  }\n}\n\nexport const addToArrayUnique = <T>(arr: T[], value: T) => {\n  const index = arr.indexOf(value)\n  if (index === -1) {\n    arr.push(value)\n  }\n}\n\nexport const removeFromArray = <T>(arr: T[], value: T, strict = false) => {\n  const index = arr.indexOf(value)\n  if (index !== -1) {\n    arr.splice(index, 1)\n  } else if (strict) {\n    throw new Error('could not find value in array')\n  }\n  return value\n}\n\nexport const moveBetweenArrays = <T>(src: T[], dst: T[], value: T) => {\n  dst.push(removeFromArray(src, value))\n  return value\n}\n\nexport const replaceManyInArray = <T>(\n  arr: Array<T | undefined>,\n  value: T,\n  replacement?: T\n) => {\n  if (value === replacement) {\n    throw new Error('Nope. This would cause an infinite loop')\n  }\n  let index = arr.indexOf(value)\n  while (index !== -1) {\n    arr[index] = replacement\n    index = arr.indexOf(value)\n  }\n}\n\nexport function getArrayDiffs<T>(oldArr: T[], newArr: T[]) {\n  const added = newArr.filter((item) => !oldArr.includes(item))\n\n  const removed = oldArr.filter((item) => !newArr.includes(item))\n\n  const equal = newArr.filter((item) => oldArr.includes(item))\n\n  return {\n    added,\n    removed,\n    equal\n  }\n}\n\nexport const pushToArrayMap = <T, T2>(\n  map: Map<T, T2[]>,\n  key: T,\n  value: T2,\n  oneCopyMax = false\n) => {\n  if (!map.has(key)) {\n    map.set(key, [])\n  }\n  const arr = map.get(key) as T2[]\n  if (arr) {\n    if (oneCopyMax) {\n      if (arr.indexOf(value) === -1) {\n        arr.push(value)\n      }\n    } else {\n      arr.push(value)\n    }\n  }\n}\n\nexport const cleanRemoveFromArrayMap = <T, T2>(\n  map: Map<T, T2[]>,\n  key: T,\n  value: T2\n) => {\n  if (!map.has(key)) {\n    return\n  }\n  const arr = map.get(key) as T2[]\n  if (arr) {\n    removeFromArray(arr, value)\n    if (arr.length === 0) {\n      map.delete(key)\n    }\n  }\n}\n\nfunction signMatches(val: number, val2: number) {\n  return val >= 0 === val2 >= 0\n}\n//binary search only works assuming numbers have been sorted from lowest to highest\nexport function findClosestNumberIndex(arr: number[], value: number): number {\n  const middleIndex = ~~(arr.length * 0.5)\n  let step = value > arr[middleIndex] ? 1 : -1\n  let index = middleIndex\n  let oldSample = arr[index]\n  let everTurned = false\n  let limit = 100\n  while (step !== 0 && limit > 0) {\n    index = clamp(index + step, 0, arr.length - 1)\n    const newSample = arr[index]\n    if (!signMatches(value - newSample, value - oldSample)) {\n      step *= -1\n      everTurned = true\n    }\n    step = absFloor(step * (everTurned ? 0.5 : 2))\n    oldSample = newSample\n    limit--\n  }\n  return index\n}\n\nexport function getArrWrap<T>(arr: T[], i: number) {\n  const t = arr.length\n  return arr[((i % t) + t) % t]\n}\n\nexport function getArrNext<T>(arr: T[], item: T) {\n  return getArrWrap(arr, arr.indexOf(item) + 1)\n}\n\nexport function getArrPrev<T>(arr: T[], item: T) {\n  return getArrWrap(arr, arr.indexOf(item) - 1)\n}\n\nexport function getArrAround<T>(arr: T[], item: T) {\n  const i = arr.indexOf(item)\n  return [getArrWrap(arr, i - 1), item, getArrWrap(arr, i + 1)]\n}\n", "import { removeFromArray } from './arrayUtils'\n\ntype ChangeCallback = (newVal: any, oldVal: any) => void\n\nclass LiveProperty {\n  get listenerCount() {\n    return this.listeners.length\n  }\n  private obj: any\n  private propName: string\n  private value: any\n  private listeners: ChangeCallback[]\n  constructor(obj: any, propName: string) {\n    this.propName = propName\n    this.listeners = []\n    this.setValue = this.setValue.bind(this)\n    this.attach(obj)\n  }\n\n  attach(obj: any) {\n    if (this.obj) {\n      this.release()\n    }\n    this.obj = obj\n    const value = this.obj[this.propName]\n    Object.defineProperty(obj, this.propName, {\n      configurable: true,\n      set: this.setValue,\n      get: () => this.value\n    })\n    this.setValue(value)\n  }\n  release() {\n    Object.defineProperty(this.obj, this.propName, {\n      value: this.value,\n      writable: true\n    })\n  }\n  hasListener(listener: ChangeCallback) {\n    return this.listeners.indexOf(listener) !== -1\n  }\n  addListener(listener: ChangeCallback, firstOneForFree = true) {\n    if (firstOneForFree) {\n      listener(this.value, undefined)\n    }\n    this.listeners.push(listener)\n  }\n  removeListener(listener: ChangeCallback) {\n    removeFromArray(this.listeners, listener)\n  }\n  private setValue(value: any) {\n    if (this.value === value) {\n      return\n    }\n    const oldValue = this.value\n    this.value = value\n    for (const listener of this.listeners) {\n      listener(value, oldValue)\n    }\n  }\n}\n\nconst propGroupLibrary = new Map<any, Map<string, LiveProperty>>()\n\nfunction getObjectPropGroup(obj: any) {\n  if (!propGroupLibrary.has(obj)) {\n    propGroupLibrary.set(obj, new Map<string, LiveProperty>())\n  }\n  return propGroupLibrary.get(obj)!\n}\n\nfunction getLiveProperty(obj: any, propName: string) {\n  const objectPropGroup = getObjectPropGroup(obj)\n  if (!objectPropGroup.has(propName)) {\n    objectPropGroup.set(propName, new LiveProperty(obj, propName))\n  }\n  return objectPropGroup.get(propName)!\n}\n\nexport function listenToProperty(\n  obj: any,\n  propName: string,\n  onChange: ChangeCallback,\n  firstOneForFree = true\n) {\n  getLiveProperty(obj, propName).addListener(onChange, firstOneForFree)\n}\n\nexport function stopListeningToProperty(\n  obj: any,\n  propName: string,\n  onChange: ChangeCallback\n) {\n  const propGroup = propGroupLibrary.get(obj)\n  if (propGroup) {\n    const liveProp = propGroup.get(propName)\n    if (liveProp) {\n      liveProp.removeListener(onChange)\n      if (liveProp.listenerCount === 0) {\n        liveProp.release()\n        propGroup.delete(propName)\n      }\n    }\n    if (propGroup.size === 0) {\n      propGroupLibrary.delete(obj)\n    }\n  }\n}\n\nexport function migrateLiveProperty(\n  oldObj: any,\n  newObj: any,\n  propName: string\n) {\n  const oldPropGroup = propGroupLibrary.get(oldObj)\n  if (oldPropGroup) {\n    const liveProp = oldPropGroup.get(propName)\n    if (liveProp) {\n      liveProp.attach(newObj)\n      oldPropGroup.delete(propName)\n      const newPropGroup = getObjectPropGroup(newObj)\n      newPropGroup.set(propName, liveProp)\n      if (oldPropGroup.size === 0) {\n        propGroupLibrary.delete(oldObj)\n      }\n    }\n  }\n}\n", "import { DataTexture, RGBAFormat, UnsignedByteType } from 'three'\n\nlet __tempTexture: DataTexture | undefined\nexport function getTempTexture() {\n  if (!__tempTexture) {\n    const s = 4\n    const total = s * s * 4\n    const data = new Uint8Array(total)\n    for (let i = 0; i < total; i++) {\n      data[i] = 0\n    }\n    __tempTexture = new DataTexture(data, s, s, RGBAFormat, UnsignedByteType)\n  }\n  return __tempTexture!\n}\n"],
  "mappings": "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",
  "names": []
}

{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils/math.ts", "../src/utils/arrayUtils.ts", "../src/utils/propertyListeners.ts", "../src/utils/threeUtils.ts", "../src/utils/colorLibrary.ts", "../src/PixelFontFace.ts", "../src/loaders/assetLoader.ts", "../src/PixelTextSettings.ts"],
  "sourcesContent": ["import {\n  BufferGeometry,\n  Camera,\n  Color,\n  DataTexture,\n  DoubleSide,\n  Group,\n  IUniform,\n  Material,\n  Matrix4,\n  Mesh,\n  NearestFilter,\n  PlaneBufferGeometry,\n  RGBAFormat,\n  RepeatWrapping,\n  Scene,\n  ShaderMaterial,\n  Texture,\n  Uniform,\n  UnsignedByteType,\n  UVMapping,\n  Vector2,\n  Vector4,\n  WebGLRenderer\n} from 'three'\nimport {\n  listenToProperty,\n  stopListeningToProperty\n} from './utils/propertyListeners'\nimport { getTempTexture } from './utils/threeUtils'\n\nimport fragmentShader from './frag.glsl'\nimport PixelFontFace from './PixelFontFace'\nimport { pixelTextSettings, PixelTextSettings } from './PixelTextSettings'\nimport vertexShader from './vert.glsl'\n\nconst __mat = new Matrix4()\n\nconst trackedFontFaceTextures: Texture[] = []\nfunction getFontFaceSubOrder(texture?: Texture) {\n  if (!texture) {\n    return -1\n  }\n  const index = trackedFontFaceTextures.indexOf(texture)\n  if (index === -1) {\n    trackedFontFaceTextures.push(texture)\n    return trackedFontFaceTextures.length - 1\n  } else {\n    return index\n  }\n}\n\nconst MAX_LINES = 2048\n\nexport default class PixelTextMesh extends Mesh {\n  width = 0\n  height = 0\n\n  dirty = false\n  livePropObject?: object\n  livePropName?: string\n\n  private _fontFace: PixelFontFace | undefined\n  private _newTexture?: Texture\n  private _newFontString?: string\n\n  constructor(\n    private _text = '',\n    public settings: PixelTextSettings = pixelTextSettings.generic,\n    public onMeasurementsUpdated?: (mesh: PixelTextMesh) => void,\n    public onCharSizeUpdated?: (width: number, height: number) => void,\n    public optimizeRenderOrder = true\n  ) {\n    super(getTextGeometry(_text, settings), initMaterial(settings))\n\n    listenToProperty(settings, 'fontFace', this.onFontFaceChange, true)\n  }\n\n  get text() {\n    return this._text\n  }\n\n  set text(text: string) {\n    if (this._text !== text) {\n      this._text = text\n      this.dirty = true\n    }\n  }\n\n  onFontFaceChange = (\n    newFontFace: PixelFontFace,\n    oldFontFace: PixelFontFace\n  ) => {\n    if (oldFontFace) {\n      stopListeningToProperty(oldFontFace, 'texture', this.onFontTextureUpdate)\n      stopListeningToProperty(oldFontFace, 'font', this.onFontUpdate)\n    }\n    listenToProperty(newFontFace, 'texture', this.onFontTextureUpdate)\n    listenToProperty(newFontFace, 'font', this.onFontUpdate)\n\n    newFontFace.init()\n    this._fontFace = newFontFace\n  }\n\n  onFontTextureUpdate = (texture: Texture) => {\n    this._newTexture = texture\n    this.dirty = true\n  }\n\n  onFontUpdate = (fontString: string) => {\n    this._newFontString = fontString\n    this.dirty = true\n  }\n\n  onBeforeRender = (\n    renderer: WebGLRenderer,\n    scene: Scene,\n    camera: Camera,\n    geometry: BufferGeometry,\n    material: Material,\n    group: Group\n  ) => {\n    if (this.settings.screenSpace) {\n      const clipPos = (this.material as ShaderMaterial)!.uniforms\n        .clipSpacePosition.value as Vector4\n      __mat\n        .multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld)\n        .premultiply(camera.projectionMatrix) //.multiply(camera.projectionMatrix)\n      clipPos.set(0, 0, 0, 1).applyMatrix4(__mat)\n    }\n    if (this.dirty) {\n      this.dirty = false\n      this.regenerateGeometry()\n      const m = this.material as ShaderMaterial\n      if (this._newTexture) {\n        if (this.optimizeRenderOrder) {\n          this.renderOrder =\n            this.renderOrder || 100 + getFontFaceSubOrder(this._newTexture)\n        }\n        m.uniforms.fontTexture.value = this._newTexture\n        this._newTexture = undefined\n      }\n      if (this._newFontString && this._text) {\n        const lines = this.text.split('\\n').slice(0, MAX_LINES)\n        const charsHeight = lines.length\n\n        const fontSettings = this.settings.fontFace\n        const maxWidthOfChar = fontSettings.maxCharPixelWidth\n        const fontString = fontSettings.font!\n        const charPixelWidths = fontSettings.pixelWidths!\n\n        const overlapPixels = -this.settings.letterSpacing\n\n        const image = (m.uniforms.fontTexture.value as Texture).image\n        m.uniforms.fontSizeInChars.value.set(\n          image.width / fontSettings.maxCharPixelWidth,\n          image.height / fontSettings.charPixelHeight\n        )\n\n        const missingCharIndex = fontString.indexOf('\u25A1')\n        if (missingCharIndex === -1) {\n          throw new Error(\n            'Please include this character \u25A1 in your font, to stand in for other missing characters'\n          )\n        }\n\n        let missingChars = ''\n\n        const linePixelWidths = lines.map((lineString) => {\n          let pixelLength = 0\n          for (let i = 0; i < lineString.length; i++) {\n            const char = lineString[i]\n            if (char == undefined) {\n              continue\n            }\n            const charIndex = fontString.indexOf(char)\n            if (charIndex === -1) {\n              pixelLength +=\n                maxWidthOfChar -\n                charPixelWidths[missingCharIndex] -\n                overlapPixels\n              if (!missingChars.includes(char)) {\n                missingChars += char\n              }\n            } else {\n              pixelLength +=\n                maxWidthOfChar - charPixelWidths[charIndex] - overlapPixels\n            }\n          }\n          return pixelLength + overlapPixels\n        })\n\n        console.warn('Characters in text not found in font: ' + missingChars)\n\n        const maxPixelWidth = linePixelWidths.reduce(\n          (p, c) => Math.max(p, c),\n          0\n        )\n\n        const total = maxPixelWidth * charsHeight\n        const data = new Uint8Array(total * 4)\n\n        for (let iy = 0; iy < charsHeight; iy++) {\n          const lineOffset = iy * maxPixelWidth\n          let xCursor = 0\n          const line = lines[iy]\n          const charsWidth = line.length\n          for (let ix = 0; ix <= charsWidth; ix++) {\n            const char = line[ix]\n            const prevChar = line[ix - 1]\n            if (!char && !prevChar) {\n              continue\n            }\n            let charIndex = fontString.indexOf(char)\n            if (charIndex === -1 && char !== undefined) {\n              charIndex = missingCharIndex\n            }\n            const charPixelWidth = maxWidthOfChar - charPixelWidths[charIndex]\n            for (let ipx = 0; ipx < charPixelWidth; ipx++) {\n              const index = (lineOffset + xCursor) * 4\n              data[index] = charIndex\n              data[index + 1] = (((xCursor - ipx) / maxWidthOfChar) % 1) * 255\n              xCursor++\n            }\n\n            //back up to overlap chars\n            xCursor -= overlapPixels\n            for (let i = 0; i < overlapPixels; i++) {\n              const index = (lineOffset + xCursor + i) * 4\n              data[index + 2] = data[index]\n              data[index + 3] = data[index + 1]\n            }\n          }\n        }\n        m.uniforms.layoutSizeInChars.value.set(\n          maxPixelWidth / maxWidthOfChar,\n          charsHeight\n        )\n        m.uniforms.layoutSizeInCharColumns.value.set(maxPixelWidth, charsHeight)\n        m.uniforms.layoutTexture.value = new DataTexture(\n          data,\n          maxPixelWidth,\n          charsHeight,\n          RGBAFormat,\n          UnsignedByteType,\n          UVMapping,\n          RepeatWrapping,\n          RepeatWrapping,\n          NearestFilter,\n          NearestFilter\n        )\n        this._newFontString = undefined\n        if (this.onCharSizeUpdated) {\n          this.onCharSizeUpdated(maxPixelWidth / maxWidthOfChar, charsHeight)\n        }\n      }\n    }\n  }\n\n  updateText = (value: any = '') => {\n    this.text = `${value}`\n  }\n\n  onRemove() {\n    stopListeningToProperty(this.settings, 'fontFace', this.onFontFaceChange)\n    if (this._fontFace) {\n      stopListeningToProperty(\n        this._fontFace,\n        'texture',\n        this.onFontTextureUpdate\n      )\n      stopListeningToProperty(this._fontFace, 'font', this.onFontUpdate)\n    }\n  }\n\n  private regenerateGeometry() {\n    this.geometry = getTextGeometry(this._text, this.settings)\n    this.updateMeasurements()\n  }\n\n  private updateMeasurements() {\n    const bb = this.geometry.boundingBox!\n    this.width = bb.max.x - bb.min.x\n    this.height = Math.abs(bb.max.y - bb.min.y)\n    this.userData.resolution = new Vector2(this.width, this.height)\n    if (this.onMeasurementsUpdated) {\n      this.onMeasurementsUpdated(this)\n    }\n  }\n}\n\ninterface TextShaderUniforms {\n  fontTexture: IUniform<Texture>\n  layoutTexture: IUniform<Texture>\n  color: IUniform<Color>\n  strokeColor: IUniform<Color>\n  clipSpacePosition?: IUniform<Vector4>\n  pixelSizeInClipSpace?: IUniform<Vector2>\n}\n\nconst initMaterial = (settings: PixelTextSettings) => {\n  const uniforms = {\n    layoutTexture: new Uniform(getTempTexture()),\n    fontTexture: new Uniform(settings.fontFace.texture),\n    color: new Uniform(new Color(settings.color)),\n    strokeColor: new Uniform(new Color(settings.strokeColor)),\n    fontSizeInChars: new Uniform(new Vector2(1, 1)),\n    layoutSizeInChars: new Uniform(new Vector2(1, 1)),\n    layoutSizeInCharColumns: new Uniform(new Vector2(1, 1))\n  }\n  const safeUniforms: TextShaderUniforms = uniforms\n\n  if (settings.screenSpace) {\n    safeUniforms.clipSpacePosition = new Uniform(new Vector4())\n    if (settings.pixelSizeInClipSpaceUniform) {\n      safeUniforms.pixelSizeInClipSpace = settings.pixelSizeInClipSpaceUniform\n    } else {\n      throw new Error(\n        'You must provide a pixelSizeInClipSpaceUniform for screenSpace mode'\n      )\n    }\n  }\n\n  const material = new ShaderMaterial({\n    defines: {\n      USE_SCREENSPACE: settings.screenSpace,\n      CONSTANT_SIZE_ON_SCREEN: settings.constantSizeOnScreen\n    },\n    uniforms,\n    vertexShader,\n    fragmentShader,\n    depthWrite: true,\n    side: DoubleSide\n  })\n\n  return material\n}\n\nconst tempBlankGeo = new PlaneBufferGeometry(0.001, 0.001)\ntempBlankGeo.computeBoundingBox()\nconst textGeo = new PlaneBufferGeometry(1, 1)\nconst attr = textGeo.attributes.position\nconst arr = attr.array as number[]\nfor (let i = 0; i < attr.count; i++) {\n  const i3 = i * 3\n  arr[i3] += 0.5\n  arr[i3 + 1] -= 0.5\n}\ntextGeo.computeBoundingBox()\n\nconst getTextGeometry = (\n  text: string,\n  settings: PixelTextSettings\n): BufferGeometry => {\n  if (settings.fontFace.font && text) {\n    return textGeo\n  } else {\n    return tempBlankGeo\n  }\n}\n", "import { Camera, Plane, Ray, Vector3 } from 'three'\n\nexport function clamp(val: number, min: number, max: number) {\n  return Math.min(max, Math.max(min, val))\n}\n\nexport function mod(val: number, freq: number) {\n  return ((val % freq) + freq) % freq\n}\n\nexport function wrap(val: number, min: number, max: number) {\n  const range = max - min\n  return ((((val - min) % range) + range) % range) + min\n}\n\nexport function absFloor(val: number) {\n  return Math.floor(Math.abs(val)) * (val < 0 ? -1 : 1)\n}\n\nconst tiny = 0.00001\nexport function closeEnough(val: number, val2: number) {\n  return Math.abs(val - val2) < tiny\n}\n\nexport const TWO_PI = 2 * Math.PI\n\nexport const RADIANS_TO_DEGREES = 180 / Math.PI\n\nexport const DEGREES_TO_RADIANS = Math.PI / 180\n\nexport function radiansToDegrees(radians: number) {\n  return radians * RADIANS_TO_DEGREES\n}\n\nexport function degreesToRadians(degrees: number) {\n  return degrees * DEGREES_TO_RADIANS\n}\n\nconst ray: Ray = new Ray()\nconst flatPlane: Plane = new Plane(new Vector3(0, -1, 0), 1)\nconst anyPlane: Plane = new Plane(new Vector3(0, -1, 0), 1)\nconst intersection: Vector3 = new Vector3()\n\n// const __cameraPosition = new Vector3()\n\nexport function get2DPositionOnPlane(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  plane: Plane\n) {\n  // __cameraPosition.set(0, 0, 0)\n  // camera.localToWorld(__cameraPosition)\n  ray.origin.copy(cameraWorldPos)\n  ray.direction.set(x, y, 0.5).unproject(camera).sub(cameraWorldPos).normalize()\n\n  ray.intersectPlane(plane, intersection)\n  return intersection\n}\nexport function get2DPositionAtDepth(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  atDepth = 0\n) {\n  flatPlane.constant = atDepth\n  return get2DPositionOnPlane(camera, cameraWorldPos, x, y, flatPlane)\n}\nexport function get2DPositionOnPlaneHelper(\n  camera: Camera,\n  cameraWorldPos: Vector3,\n  x: number,\n  y: number,\n  coPlanarPoint: Vector3,\n  normal: Vector3\n) {\n  anyPlane.setFromNormalAndCoplanarPoint(normal, coPlanarPoint)\n  return get2DPositionOnPlane(camera, cameraWorldPos, x, y, anyPlane)\n}\n\nexport function lerp(a: number, b: number, dt: number) {\n  const out = a + dt * (b - a)\n  return Math.abs(b - out) > 0.00001 ? out : b\n}\n\nexport function unlerp(min: number, max: number, value: number) {\n  return (value - min) / (max - min)\n}\n\nexport function unlerpClamped(min: number, max: number, value: number) {\n  return clamp(unlerp(min, max, value), 0, 1)\n}\n\nexport function degreesDifference(A: number, B: number) {\n  return ((((A - B) % 360) + 540) % 360) - 180\n}\n\nconst tau = Math.PI * 2\nconst tauAndHalf = Math.PI * 3\nexport function radiansDifference(a: number, b: number) {\n  return ((((a - b) % tau) + tauAndHalf) % tau) - Math.PI\n}\n\nexport function rand(min = 0, max = 1) {\n  return Math.random() * (max - min) + min\n}\n\nexport function rand2(scale = 1, offset = 0) {\n  return (Math.random() * 2 - 1) * scale + offset\n}\n\nexport function nextHighestPowerOfTwo(val: number) {\n  return Math.pow(Math.ceil(Math.sqrt(val)), 2)\n}\n\nexport function inferDirection(val: number, tolerance = 0.00001) {\n  if (val < -tolerance) {\n    return -1\n  } else if (val > tolerance) {\n    return 1\n  } else {\n    return 0\n  }\n}\n\nexport function sqr(v: number) {\n  return v * v\n}\n\nexport function pixelLengthOnScreen(a: Vector3, b: Vector3, camera: Camera) {\n  a.project(camera)\n  b.project(camera)\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n}\n\nconst phi = (Math.sqrt(5) + 1) * 0.5 - 1\nconst ga = phi * Math.PI * 2\nexport function pointOnSphereFibonacci(\n  index: number,\n  total: number\n): [number, number] {\n  //[long, lat];\n  return [ga * index, Math.asin(-1 + (2 * index) / total)]\n}\n\nexport function longLatToXYZ(\n  longLat: [number, number],\n  radius: number\n): [number, number, number] {\n  const long = longLat[0]\n  const lat = longLat[1]\n  return [\n    Math.cos(lat) * Math.cos(long) * radius,\n    Math.sin(lat) * radius,\n    Math.cos(lat) * Math.sin(long) * radius\n  ]\n}\n\nexport function powerOfTwo(x: number) {\n  return Math.log2(x) % 1 === 0\n}\n\nexport function assertPowerOfTwo(x: number) {\n  if (!powerOfTwo(x)) {\n    throw new Error(`${x} is not a power of two`)\n  }\n}\n", "import { absFloor, clamp } from './math'\nexport const scaleValuesInArray = (arr: number[], scale: number) => {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] *= scale\n  }\n}\n\nexport const addToArrayUnique = <T>(arr: T[], value: T) => {\n  const index = arr.indexOf(value)\n  if (index === -1) {\n    arr.push(value)\n  }\n}\n\nexport const removeFromArray = <T>(arr: T[], value: T, strict = false) => {\n  const index = arr.indexOf(value)\n  if (index !== -1) {\n    arr.splice(index, 1)\n  } else if (strict) {\n    throw new Error('could not find value in array')\n  }\n  return value\n}\n\nexport const moveBetweenArrays = <T>(src: T[], dst: T[], value: T) => {\n  dst.push(removeFromArray(src, value))\n  return value\n}\n\nexport const replaceManyInArray = <T>(\n  arr: Array<T | undefined>,\n  value: T,\n  replacement?: T\n) => {\n  if (value === replacement) {\n    throw new Error('Nope. This would cause an infinite loop')\n  }\n  let index = arr.indexOf(value)\n  while (index !== -1) {\n    arr[index] = replacement\n    index = arr.indexOf(value)\n  }\n}\n\nexport function getArrayDiffs<T>(oldArr: T[], newArr: T[]) {\n  const added = newArr.filter((item) => !oldArr.includes(item))\n\n  const removed = oldArr.filter((item) => !newArr.includes(item))\n\n  const equal = newArr.filter((item) => oldArr.includes(item))\n\n  return {\n    added,\n    removed,\n    equal\n  }\n}\n\nexport const pushToArrayMap = <T, T2>(\n  map: Map<T, T2[]>,\n  key: T,\n  value: T2,\n  oneCopyMax = false\n) => {\n  if (!map.has(key)) {\n    map.set(key, [])\n  }\n  const arr = map.get(key) as T2[]\n  if (arr) {\n    if (oneCopyMax) {\n      if (arr.indexOf(value) === -1) {\n        arr.push(value)\n      }\n    } else {\n      arr.push(value)\n    }\n  }\n}\n\nexport const cleanRemoveFromArrayMap = <T, T2>(\n  map: Map<T, T2[]>,\n  key: T,\n  value: T2\n) => {\n  if (!map.has(key)) {\n    return\n  }\n  const arr = map.get(key) as T2[]\n  if (arr) {\n    removeFromArray(arr, value)\n    if (arr.length === 0) {\n      map.delete(key)\n    }\n  }\n}\n\nfunction signMatches(val: number, val2: number) {\n  return val >= 0 === val2 >= 0\n}\n//binary search only works assuming numbers have been sorted from lowest to highest\nexport function findClosestNumberIndex(arr: number[], value: number): number {\n  const middleIndex = ~~(arr.length * 0.5)\n  let step = value > arr[middleIndex] ? 1 : -1\n  let index = middleIndex\n  let oldSample = arr[index]\n  let everTurned = false\n  let limit = 100\n  while (step !== 0 && limit > 0) {\n    index = clamp(index + step, 0, arr.length - 1)\n    const newSample = arr[index]\n    if (!signMatches(value - newSample, value - oldSample)) {\n      step *= -1\n      everTurned = true\n    }\n    step = absFloor(step * (everTurned ? 0.5 : 2))\n    oldSample = newSample\n    limit--\n  }\n  return index\n}\n\nexport function getArrWrap<T>(arr: T[], i: number) {\n  const t = arr.length\n  return arr[((i % t) + t) % t]\n}\n\nexport function getArrNext<T>(arr: T[], item: T) {\n  return getArrWrap(arr, arr.indexOf(item) + 1)\n}\n\nexport function getArrPrev<T>(arr: T[], item: T) {\n  return getArrWrap(arr, arr.indexOf(item) - 1)\n}\n\nexport function getArrAround<T>(arr: T[], item: T) {\n  const i = arr.indexOf(item)\n  return [getArrWrap(arr, i - 1), item, getArrWrap(arr, i + 1)]\n}\n", "import { removeFromArray } from './arrayUtils'\n\ntype ChangeCallback = (newVal: any, oldVal: any) => void\n\nclass LiveProperty {\n  get listenerCount() {\n    return this.listeners.length\n  }\n  private obj: any\n  private propName: string\n  private value: any\n  private listeners: ChangeCallback[]\n  constructor(obj: any, propName: string) {\n    this.propName = propName\n    this.listeners = []\n    this.setValue = this.setValue.bind(this)\n    this.attach(obj)\n  }\n\n  attach(obj: any) {\n    if (this.obj) {\n      this.release()\n    }\n    this.obj = obj\n    const value = this.obj[this.propName]\n    Object.defineProperty(obj, this.propName, {\n      configurable: true,\n      set: this.setValue,\n      get: () => this.value\n    })\n    this.setValue(value)\n  }\n  release() {\n    Object.defineProperty(this.obj, this.propName, {\n      value: this.value,\n      writable: true\n    })\n  }\n  hasListener(listener: ChangeCallback) {\n    return this.listeners.indexOf(listener) !== -1\n  }\n  addListener(listener: ChangeCallback, firstOneForFree = true) {\n    if (firstOneForFree) {\n      listener(this.value, undefined)\n    }\n    this.listeners.push(listener)\n  }\n  removeListener(listener: ChangeCallback) {\n    removeFromArray(this.listeners, listener)\n  }\n  private setValue(value: any) {\n    if (this.value === value) {\n      return\n    }\n    const oldValue = this.value\n    this.value = value\n    for (const listener of this.listeners) {\n      listener(value, oldValue)\n    }\n  }\n}\n\nconst propGroupLibrary = new Map<any, Map<string, LiveProperty>>()\n\nfunction getObjectPropGroup(obj: any) {\n  if (!propGroupLibrary.has(obj)) {\n    propGroupLibrary.set(obj, new Map<string, LiveProperty>())\n  }\n  return propGroupLibrary.get(obj)!\n}\n\nfunction getLiveProperty(obj: any, propName: string) {\n  const objectPropGroup = getObjectPropGroup(obj)\n  if (!objectPropGroup.has(propName)) {\n    objectPropGroup.set(propName, new LiveProperty(obj, propName))\n  }\n  return objectPropGroup.get(propName)!\n}\n\nexport function listenToProperty(\n  obj: any,\n  propName: string,\n  onChange: ChangeCallback,\n  firstOneForFree = true\n) {\n  getLiveProperty(obj, propName).addListener(onChange, firstOneForFree)\n}\n\nexport function stopListeningToProperty(\n  obj: any,\n  propName: string,\n  onChange: ChangeCallback\n) {\n  const propGroup = propGroupLibrary.get(obj)\n  if (propGroup) {\n    const liveProp = propGroup.get(propName)\n    if (liveProp) {\n      liveProp.removeListener(onChange)\n      if (liveProp.listenerCount === 0) {\n        liveProp.release()\n        propGroup.delete(propName)\n      }\n    }\n    if (propGroup.size === 0) {\n      propGroupLibrary.delete(obj)\n    }\n  }\n}\n\nexport function migrateLiveProperty(\n  oldObj: any,\n  newObj: any,\n  propName: string\n) {\n  const oldPropGroup = propGroupLibrary.get(oldObj)\n  if (oldPropGroup) {\n    const liveProp = oldPropGroup.get(propName)\n    if (liveProp) {\n      liveProp.attach(newObj)\n      oldPropGroup.delete(propName)\n      const newPropGroup = getObjectPropGroup(newObj)\n      newPropGroup.set(propName, liveProp)\n      if (oldPropGroup.size === 0) {\n        propGroupLibrary.delete(oldObj)\n      }\n    }\n  }\n}\n", "import { DataTexture, RGBAFormat, UnsignedByteType } from 'three'\n\nlet __tempTexture: DataTexture | undefined\nexport function getTempTexture() {\n  if (!__tempTexture) {\n    const s = 4\n    const total = s * s * 4\n    const data = new Uint8Array(total)\n    for (let i = 0; i < total; i++) {\n      data[i] = 0\n    }\n    __tempTexture = new DataTexture(data, s, s, RGBAFormat, UnsignedByteType)\n  }\n  return __tempTexture!\n}\n", "import { Color } from 'three'\n\nexport const COLOR_BLACK: Readonly<Color> = new Color(0x000000)\nexport const COLOR_WHITE: Readonly<Color> = new Color(0xffffff)\nexport const COLOR_HIGHLIGHT_GREEN: Readonly<Color> = new Color(0x66ff66)\nexport const COLOR_HIGHLIGHT_RED: Readonly<Color> = new Color(0x22afff)\nexport const COLOR_BUFFED_TEXT: Readonly<Color> = new Color(0x66ff66)\nexport const COLOR_NERFED_TEXT: Readonly<Color> = new Color(0xff0000)\nexport const COLOR_DYNAMIC_COST_TEXT: Readonly<Color> = new Color(0xf4e842)\n", "import { NearestFilter, Texture } from 'three'\nimport { loadText, loadTexture } from './loaders/assetLoader'\n\nfunction url(path: string, ext: string) {\n  return `${path}.${ext}`\n}\nexport default class PixelFontFace {\n  font?: string\n  pixelWidths?: number[]\n  texture?: Texture\n  private _initd = false\n  constructor(\n    public name: string,\n    public maxCharPixelWidth = 7,\n    public charPixelHeight = 8\n  ) {}\n  async init() {\n    if (this._initd) {\n      return\n    }\n    this._initd = true\n\n    this.texture = await loadTexture(url(this.name, 'png'))\n    this.texture.minFilter = NearestFilter\n    this.texture.magFilter = NearestFilter\n\n    const pixelWidthsString = (\n      await loadText(url(this.name + '_char-widths', 'txt'))\n    )\n      .split('\\n')\n      .join('')\n    const pixelWidths = []\n    for (let i = 0; i < pixelWidthsString.length; i++) {\n      pixelWidths[i] = parseInt(pixelWidthsString[i])\n    }\n    this.pixelWidths = pixelWidths\n    this.font = (await loadText(url(this.name, 'txt'))).split('\\n').join('')\n  }\n}\n\nexport const pixelFontFaces = {\n  cdogs_font_7x8: new PixelFontFace('pixelFonts/cdogs_font_7x8', 7, 8),\n  good_neighbors: new PixelFontFace('pixelFonts/good_neighbors', 11, 16)\n}\n", "import { FileLoader, LoadingManager, Texture, TextureLoader } from 'three'\n\nconst __loadingManager = new LoadingManager()\n\nlet __fileLoader: FileLoader | undefined\nfunction getFileLoader() {\n  if (!__fileLoader) {\n    __fileLoader = new FileLoader(__loadingManager)\n  }\n  return __fileLoader\n}\n\nlet __textureLoader: TextureLoader | undefined\nfunction getTextureLoader() {\n  if (!__textureLoader) {\n    __textureLoader = new TextureLoader(__loadingManager)\n  }\n  return __textureLoader\n}\n\nexport async function loadJson(url: string): Promise<object> {\n  return new Promise<object>((resolve, reject) =>\n    getFileLoader().load(\n      url,\n      (fileContents: string) => resolve(JSON.parse(fileContents)),\n      undefined,\n      reject\n    )\n  )\n}\n\nexport async function loadText(url: string): Promise<string> {\n  return new Promise<string>((resolve, reject) =>\n    getFileLoader().load(\n      url,\n      (fileContents: string) => resolve(fileContents),\n      undefined,\n      reject\n    )\n  )\n}\n\nconst __currentlyLoadingTextureResolvers = new Map<\n  string,\n  Array<(texture: Texture) => void>\n>()\nexport async function loadTexture(\n  url: string,\n  flipY?: boolean\n): Promise<Texture> {\n  let promise: Promise<Texture>\n  if (__currentlyLoadingTextureResolvers.has(url)) {\n    promise = new Promise<Texture>((resolve, reject) => {\n      __currentlyLoadingTextureResolvers.get(url)!.push(resolve)\n    })\n  } else {\n    promise = new Promise<Texture>((resolve, reject) => {\n      __currentlyLoadingTextureResolvers.set(url, [resolve])\n      const onLoad = (texture: Texture) => {\n        // texture.needsUpdate = true\n        texture.name = url\n        // texture.encoding = sRGBEncoding\n        if (flipY !== undefined) {\n          texture.flipY = flipY\n        }\n        // XXX Using this filter to get rid of NPOT warnings, is not best quality fix later\n        // texture.minFilter = NearestFilter\n        // texture.magFilter = NearestFilter\n        __currentlyLoadingTextureResolvers\n          .get(url)!\n          .forEach((resolve) => resolve(texture))\n        __currentlyLoadingTextureResolvers.delete(url)\n      }\n      getTextureLoader().load(url, onLoad, undefined, reject)\n    })\n  }\n  return promise\n}\n", "import { Color, Uniform } from 'three'\nimport {\n  COLOR_BLACK,\n  COLOR_BUFFED_TEXT,\n  COLOR_WHITE\n} from './utils/colorLibrary'\n\nimport PixelFontFace, { pixelFontFaces } from './PixelFontFace'\n\nexport interface PixelTextSettings {\n  fontFace: PixelFontFace\n  color: Color\n  strokeColor: Color\n  scaleDownToPhysicalSize: boolean\n  screenSpace: boolean\n  pixelSizeInClipSpaceUniform?: Uniform\n  constantSizeOnScreen?: boolean\n  letterSpacing: number\n}\n\nconst generic: PixelTextSettings = {\n  fontFace: pixelFontFaces.cdogs_font_7x8,\n  color: COLOR_WHITE,\n  letterSpacing: -1,\n  strokeColor: COLOR_BLACK,\n  scaleDownToPhysicalSize: true,\n  screenSpace: false,\n  constantSizeOnScreen: false\n}\nconst title: PixelTextSettings = {\n  ...generic,\n  color: COLOR_BUFFED_TEXT\n}\n\nexport const pixelTextSettings = {\n  generic,\n  title\n}\n"],
  "mappings": "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",
  "names": []
}
